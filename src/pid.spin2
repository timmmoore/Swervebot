{PID}


CON
  DEBUG_OUTPUT      =           500

OBJ
  serial        : "isp_serial_singleton_tmm"
  utilities     : "utilities"

VAR
  long sch, maxwrap, maxoutput
  long sKp, sKi, sKd                                    ' float, defaults to 0.0
  long currentpos, setpos
  long error1, error2                                   ' float, defaults to 0.0
  long lasttime, lastout
  word debug3

PUB null()
  ' This is not a top-level object

PUB init(ch, wrap, out)
  longmove(@sch, @ch, 3)
  lastout := currentpos := -1
  lasttime := getms()

PUB setconstants(ch, Kp, Ki, Kd)
  ' out us maximum output value
  ' wrap is maximum input value
  if utilities.longcomp(@sKp, @Kp, 3, 0, true) && debugoutput(UTILITIES.DEBUGOUT1)
    ' Kp, Ki, Kd are floats
    serial.fstr4(string("PID%d constants %.2g %.2g %.2g\r"), ch, sKp, sKi, sKd)

PUB currentposition(value)
  if (value <> currentpos\value) && debugoutput(UTILITIES.DEBUGOUT3)
    serial.fstr2(string("PID%d currentposition %d\r"), sch, currentpos)

PUB setposition(value)
  if (value <> setpos\value) && debugoutput(UTILITIES.DEBUGOUT3)
    serial.fstr2(string("PID%d setposition %d\r"), sch, setpos)

{
https://en.wikipedia.org/wiki/PID_controller

  A0 := Kp + Ki*dt + Kd/dt
  A1 := -Kp - 2*Kd/dt
  A2 := Kd/dt
  error[2] := 0 ' e(t-2)
  error[1] := 0 ' e(t-1)
  error[0] := 0 ' e(t)
  output := u0  ' Usually the current value of the actuator

loop:
  error[2] := error[1]
  error[1] := error[0]
  error[0] := setpoint - measured_value
  output := output + A0 * error[0] + A1 * error[1] + A2 * error[2]
  wait(dt)
  goto loop
}
PUB output() : out, delta | dt, time, A0, A1, A2, error0
'' output is +- maxoutput
  ' calculate dt and A? constants each time, A2 default to 0.0
  dt := float((time := getms()) - lasttime\time)/.1000.0
  ifnot dt ==. 0.0
    A2 := sKd/.dt
  A0 := sKp +. sKi*.dt +. A2
  A1 := -2.0*.A2 -. sKp
  ' error0 is shortest angle allowing for wrapping
  error0 := float(delta := utilities.wrapangles(currentpos, setpos, maxwrap))
  out := utilities.clamp(lastout + round(A0*.error0 +. A1*.error1 +. A2*.error2), maxoutput)
  ' how long the above calculations took
  time := getms() - time
  if (out <> lastout) && debugoutput(UTILITIES.DEBUGOUT1)
    serial.fstr5(string("PID%d output o:%d lo:%d c:%d s:%d"), sch, out, lastout, currentpos, setpos)
    serial.fstr7(string(" dt:%.4g A0:%.2g E0:%.2g A1:%.2g E1:%.2g A2:%.2g E2:%.2g\r"), dt, A0, error0, A1, error1, A2, error2)
  ' update inputs for next time, lasttime already been updated
  error2, error1, lastout := error1, error0, out

PRI debugoutput(type) : retv
  retv := utilities.debugoutput(debug3, type)

PUB updatedebug(tdebug3)
  debug3 := tdebug3
'