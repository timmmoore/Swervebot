{Swerve bot}

{
  3S lithium battery
        -> 5V regulator -> propeller 2
                -> debug serial to PC (tx(62), rx(63))
                -> 1x radio (sbus_in(7), SPORT(6), sbus_out(5), 5V, Gnd)
                      FrSky R-XSR
                      SPORT sends telemetry: GPS, yaw, pitch, roll, speed/angle of each swerve module
                -> 2x motor driver (SCL(22), SDA(23), Vio, Gnd)
                      I2C motor drivers with PCA9865 and 2x TN6612
                      https://www.tindie.com/products/cburgess129/quad-motor-servo-shield-for-wireless-dev-board/
                      motor is rev HD motor 6000 rpm free speed, quadrature encoder 28 counts/rev
                                drive :gearing 1:3 planetary, 12:30 to drive leg, 1:2 wheel bevel -> 1:15
                                       400 rpm @ wheel, wheel is 2" diameter -> 2500 in/min -> ground speed is 3.5 ft/sec
                                steering: gearing 1:3, 1:4 planetary, 10:40 -> 1:48
                                       absolute angle encoder
                -> 4x encoder (5V, Gnd, pwm(8, 9, 10, 11))
                      https://store.ctr-electronics.com/srx-mag-encoder/
                -> USFSMax (SCL(20), SDA(21), Vio, Gnd)
                      https://www.tindie.com/products/onehorse/usfsmax-module-and-carrier/
                -> GPS PA1010D (SCL(25), SDA(24), Vio, Gnd)
                      https://www.adafruit.com/product/4415
                -> PMW3901 (CS(19), SCK(18), SO(17), SI(15), Vio, Gnd)
                      https://shop.pimoroni.com/products/pmw3901-optical-flow-sensor-breakout?variant=27869870358611
                -> Battery Voltage (31), 8K2, 3K resistor network
                -> 4x quadrature encoders (Gnd, 3V3, A (14, 12, 3, 1), B (15, 13, 2, 0)), 1:3, 12:30, 1:2 -> 1:15
                      7 ticks or 28 count/rev

TODO
  Map USFSMax yaw angle to bot rotation
        User specifies deg/sec and translated to yaw angle deg/sec
  Map pwm3901 x, y to bot x, y
        user specifies x,y/sec and translated to optical x,y/sec
        How does rotation translate to x,y change
                80mm from ground, angle of 42deg
                distance = (sensor value * 80mm)/(sensor resolution * scalar) * 2.0 * tan(42/2)

}

con { timing }

  CLK_FREQ = 200_000_000                                                        ' system freq as a constant
  MS_001   = CLK_FREQ / 1_000                                                   ' ticks in 1ms
  US_001   = CLK_FREQ / 1_000_000                                               ' ticks in 1us

  BR_SERIAL = 115_200                                                           ' terminal baud rate

  _clkfreq = CLK_FREQ                                                           ' set system clock

con { fixed io pins }

  RX1                           = 63  { I }                                     ' programming / debug
  TX1                           = 62  { O }

  SF_CS                         = 61  { O }                                     ' serial flash
  SF_SCK                        = 60  { O }
  SF_SDO                        = 59  { O }
  SF_SDI                        = 58  { I }

  SD_SCK                        = 61  { O }                                     ' sd card
  SD_CS                         = 60  { O }
  SD_SDI                        = 59  { O }
  SD_SDO                        = 58  { I }

  NOCHANNELS                    = 18                                            ' number of channels

  CHANNEL_X                     = 1                                             ' 1 - x speed
  CHANNEL_Y                     = 0                                             ' 2 - y speed
  CHANNEL_R                     = 3                                             ' 3 - rotate speed
  CHANNEL_OFF                   = 2                                             ' 4 - throttle/disable motors
  CHANNEL_KP                    = 4                                             ' 5 - pid Kp ls
  CHANNEL_KI                    = 5                                             ' 6 - pid Ki rs
  CHANNEL_KD                    = 6                                             ' 7 - pid Kd s1
  CHANNEL_DEBUG1                = 7                                             ' 8 - debug values sa
  CHANNEL_DEBUG2                = 8                                             ' 9                sb
  CHANNEL_DEBUG3                = 9                                             ' 10               sc

  MINDELTA                      = 5                                             ' minimum channel change

  SBUS_RX                       = 7                                             ' rx channels from transmitter
  SBUS_SPORT                    = 6                                             ' bi-directional: poll from receiver, send sensor values
  SBUS_TX                       = 5                                             ' not used
  SPORT_PHYSICAL_ID             = $22 '1B                                           ' id that R-XSR polls for sensor telemetry
  SPORT_COMMAND_ID              = $1B

  MOTOR_SDA                     = 23                                            ' i2c pins for motor controllers
  MOTOR_SCL                     = 22                                            ' SCK speed of 800KHz

  ENCODERPIN1                   = 8                                             ' pwm encoder pins, must be contiguous pins
  ENCODERPIN2                   = 9
  ENCODERPIN3                   = 10
  ENCODERPIN4                   = 11

  DRIVEENCODER1A                = 15                                            ' FL
  DRIVEENCODER1B                = 14
  DRIVEENCODER2A                = 3                                             ' FR
  DRIVEENCODER2B                = 2
  DRIVEENCODER3A                = 13                                            ' BL
  DRIVEENCODER3B                = 12
  DRIVEENCODER4A                = 1                                             ' BR
  DRIVEENCODER4B                = 0

  ' min 98-101 max:402035-415613
  ' if use spec ranges then error bar is 20-30% which causes large 'deadband' around 0 and the pids oscillate
  ' using actual ranges which have error of 2-3%, much smaller 'deadband'
  MININCLK                      = 98 '90                                        ' min encoder PWM width 0.9-1.1us * 100
  MAXINCLK                      = 415600 '450600                                ' max encoder PWM width 3696-4506us * 100

  'PMW_VCC   = 3.3V
  'PMW_GND
  PMW_CS                        = 19  { O, 3.3V level }                         ' spi pins for optical flow sensor
  PMW_SCK                       = 18  { O, 3.3V level }                         ' SCK speed of 4Mhz
  PMW_SDO                       = 17  { O, 3.3V level }
  PMW_SDI                       = 16  { I, 3.3V level }

  PMW_X_INVERT                  = false                                         ' default init orientation
  PMW_Y_INVERT                  = true
  PMW_XY_SWAP                   = true                                          ' swap x and y axis
  PMW_LED                       = false

  ' USFSMAX_VCC = 3.3V
  ' USFSMAX_GND
  USFSMAX_SDA                   = 21                                            ' i2c pins for IMU
  USFSMAX_SCL                   = 20                                            ' different I2C bus from motor driver as supports much faster clock speed
                                                                                ' SLK speed of 3Mhz
  USFSMAX_RESET                 = -1                                            ' reset pin is optional

  BATTERY_ANALOG                = 31                                            ' battery via resistor divider
                                                                                ' 8K2 + 3K3

  BATTERY_LOW                   = 0
  BATTERY_HIGH                  = 33482                                         ' 8K2 + 3K resistor divider, max voltage is 12.5V * 3000/11200 -> 3.3482
  BATTERY_DIVIDER               = 2678.56                                       ' 33482/2678.56 -> 12.5
  BATTERY_MINIMUM               = 9.9                                           ' minimum voltage
  BATTERY_TEST                  = true

  ' Bellevue, WA 98008
  M_V                           = 49.4643
  M_H                           = 19.0285
  MAG_DECLINIATION              = 15.2473
  QUAT_DIV                      = $07

  PITCH                         = 0
  ROLL                          = 1
  YAW                           = 2
  PRESSURE                      = 3

  GPS_SDA                       = 24                                            ' PA1010D I2C GPS - 400KHz/3.4MHz clock speed
  GPS_SCL                       = 25

  #1, OK, FAILSAFE, LOST                                                        ' SBUS states

  SENSORPERIOD                  = 50                                            ' ms between sensor query
  SWERVEPERIOD                  = 20                                            ' ms between RC receiver/swerve motor updates

  CHANNELCHANGE                 = $01                                           ' radio state change
  CHANNELSTATE                  = $02                                           ' radio channel change
  PMWCHANGE                     = $04                                           ' pmw
  IMUCHANGE                     = $08                                           ' imu
  GPSCHANGE                     = $10                                           ' gps
  VOLTAGECHANGE                 = $20

  PIDCONSTANTSDIVIDER10         = 10.0
  PIDCONSTANTSDIVIDER100        = 100.0
  PIDCONSTANTSDIVIDER1000       = 1000.0
  MINPIDCONSTANT                = -1000                                         ' PID constants are in range +-4.0
  MAXPIDCONSTANT                = 1000

  MINSBUSCHANNEL                = 172                   '240
  MAXSBUSCHANNEL                = 1810                  '1807
  MIDSBUSCHANNEL                = (MAXSBUSCHANNEL+MINSBUSCHANNEL)/2

  MINDEBUG                      = 500
  MAXDEBUG                      = 2000
  INIT_DEBUG                    = 500

  MINDEFAULT                    = 0
  MAXDEFAULT                    = 1000

  SHAREDPMW                     = 5                     ' xsensor_l, xsensor_h, ysensor_l, ysensor_h, tsensor                     '
  SHAREDIMU                     = 4                     ' osensor
  SHAREDGPS                     = 11                    ' ogpst, ohour, omin, osec, onorthdeg, owestdeg, ospeed, oalt, ofix, osatno, ohdop
  SHAREVOLTAGE                  = 1
  SHAREDVARIABLES               = 1+NOCHANNELS+SHAREDIMU+SHAREDPMW+SHAREDGPS+1

  NO_SWERVE_MODULES             = 4

VAR
  ' shared variables
  long synclock, printlock

  long sharedupdate, channels[NOCHANNELS], output[4], deltax_l, deltax_h, deltay_l, deltay_h, deltat
  long gpst, hour, min, sec, northdeg, westdeg, speed, alt, fix, satno, hdop, voltage

  ' swerve cog
  long swerveupdate, swervechannels[NOCHANNELS], oswerve[4], xswerve_l, xswerve_h, yswerve_l, yswerve_h, tswerve   ' swerve cog locals
  long sgpst, shour, smin, ssec, snorthdeg, swestdeg, sspeed, salt, sfix, ssatno, shdop, svoltage

  long lastchannels[NOCHANNELS]
  long debug1

  ' sensor cog
  long sensorupdate, sbuschannels[NOCHANNELS], osensor[4], xsensor_l, xsensor_h, ysensor_l, ysensor_h, tsensor     ' sensor cog locals
  long ogpst, ohour, omin, osec, onorthdeg, owestdeg, ospeed, oalt, ofix, osatno, ohdop, ovoltage

  long osensor1[4]
  long qt[4]
  long stopped                                                  ' stop bot if true
  long StkAddr[10000]

OBJ
                                                                '  main cog - swerve system
                                                                '  2nd cog - query sensors
  serial        : "isp_serial_singleton_tmm"
  sbus          : "jm_sbus_rx"                                  ' 1 cog - read sbus from receiver
  sport         : "frskysport"                                  ' 1 cog - handling polling from receiver for telemetry
  swerve        : "swervemotor" | MAX_SWERVE_MODULES=NO_SWERVE_MODULES
  utilities     : "utilities"
  pmw           : "pmw3901"                                     ' Optical flow
  usfsmax       : "usfsmax"                                     ' IMU
  gps           : "gps_pa1010d"                                 ' GPS
  battery       : "jm_ez_analog"                                ' A2D to read battery voltage

PUB main() | ch, havemotors, cognum, debug2, debug3, debugo, delaystart, acq_time, again, temp, temp1, speeds[NO_SWERVE_MODULES], aspeeds[NO_SWERVE_MODULES], angles[NO_SWERVE_MODULES]
  debug1, debug2, debug3 := INIT_DEBUG, INIT_DEBUG, INIT_DEBUG
  longfill(@lastchannels, -1, NOCHANNELS)
  serial.start(BR_SERIAL)

  waitms(100)
  if debugoutput(UTILITIES.DEBUGOUT4)
    serial.fstr0(string("Swerve Controller\r"))

  ' lock used to synchronize sensor Input across cogs
  if (synclock := locknew()) < 0
    if debugoutput(UTILITIES.DEBUGOUT1)
      serial.fstr0(string("Swerve Controller failed to allocate synclock\r"))
  ' lock used to synchronize printing across cogs
  if (printlock := locknew()) < 0
    if debugoutput(UTILITIES.DEBUGOUT1)
      serial.fstr0(string("Swerve Controller failed to allocate printlock\r"))

  swerve.debugconfig(debug2, debug3)
  dopidconstants(true)

  ' initialize server modules and motors
  if (havemotors := swerve.start(MOTOR_SCL, MOTOR_SDA, ENCODERPIN1, @bot, @pinoffsets, @angleoffsets, @minencoder, @maxencoder, @invert, @motoroffsets, @driveencoders))
    if debugoutput(UTILITIES.DEBUGOUT1)
      if havemotors & $01
        serial.fstr1(string("Swerve motors I2C bus error %x\r"), havemotors)
      if havemotors & (swerve.NO_MOTOR1|swerve.NO_MOTOR2)
        serial.fstr1(string("Swerve motors not found %x\r"), havemotors)

  '' initialize sensors
  cognum := COGSPIN(newcog, runsensors(), @StkAddr)
  waitms(50)

  delaystart := getms()

  repeat
    waitms(temp := ((SWERVEPERIOD - (getms() - delaystart)) #> 1)) ' max delay SWERVEPERIOD
    if stopped                                          ' bot needs to be stopped
      serial.fstr0(string("Swerve stopped\r"))
      waitms(100)                                       ' let the message out
      quit                                              ' stop cog
    ' make sure shared variables are not being updated
    ' copy to local variables
    acq_time := getms()
    takesynclock()
    longmove(@swerveupdate, @sharedupdate, SHAREDVARIABLES) ' copy shared variables to local copy
    releasesynclock()

    ' use local variables and see if any channel changes or swerve modules need updating again
    if swerveupdate & CHANNELCHANGE || again
      ' update local debug variable before using it
        debug1, debug2, debug3 := swervechannels[CHANNEL_DEBUG1], swervechannels[CHANNEL_DEBUG2], swervechannels[CHANNEL_DEBUG3]
      ' update remaining debug values through system
        swerve.debugconfig(debug2, debug3)
      ' take the print lock if any debug level is on
      if debugo := (debugoutput(UTILITIES.DEBUGOUT1) || utilities.debugoutput(debug2, UTILITIES.DEBUGOUT1) || utilities.debugoutput(debug3, UTILITIES.DEBUGOUT1))
        takeprintlock()

      dopidconstants(false)

      delaystart := getms()                             ' delay from after motors updated, debug print delays still part of processing time
      ' update swerve modules with updated movements
      if havemotors <> (swerve.NO_MOTOR1|swerve.NO_MOTOR2)
        again := swerve.update(swervechannels[CHANNEL_Y], swervechannels[CHANNEL_X], swervechannels[CHANNEL_R], swervechannels[CHANNEL_OFF])
      swerve.getactuals(@speeds, @aspeeds, @angles)
      sport.setactuals(@speeds, @aspeeds, @angles)      ' swerve speeds/angles telemetry
      if debugo
        if debugoutput(UTILITIES.DEBUGOUT3)
          serial.fstr2(string("Swerve period %d %d\r"), temp1 := getms()-acq_time, temp)
        releaseprintlock()                              ' release lock soon as we have finished printing
    else
      delaystart := getms()                             ' delay from after motors updated, debug print delays still part of processing time

PRI dopidconstants(init) | tSkp[NO_SWERVE_MODULES], tSki[NO_SWERVE_MODULES], tSkd[NO_SWERVE_MODULES], tDkp[NO_SWERVE_MODULES], tDki[NO_SWERVE_MODULES], tDkd[NO_SWERVE_MODULES], omax[2], i
  ' update pid constants
  ' start with defaults
  longmove(@tSkp, @defaultSteerKp, NO_SWERVE_MODULES)
  longmove(@tSki, @defaultSteerKi, NO_SWERVE_MODULES)
  longmove(@tSkd, @defaultSteerKd, NO_SWERVE_MODULES)
  longmove(@tDkp, @defaultDriveKp, NO_SWERVE_MODULES)
  longmove(@tDki, @defaultDriveKi, NO_SWERVE_MODULES)
  longmove(@tDkd, @defaultDriveKd, NO_SWERVE_MODULES)
  ' if not init then radio values delta on top of the defaults
  ifnot init
    repeat i from 0 to NO_SWERVE_MODULES-1
      tDkp[i] := float(swervechannels[CHANNEL_KP])/.PIDCONSTANTSDIVIDER100 +. tDkp[i]
      tDki[i] := float(swervechannels[CHANNEL_KI])/.PIDCONSTANTSDIVIDER100 +. tDki[i]
      tDkd[i] := float(swervechannels[CHANNEL_KD])/.PIDCONSTANTSDIVIDER1000 +. tDkd[i]

  if debugoutput(UTILITIES.DEBUGOUT3)
    serial.fstr4(string("radio %d steer pid:%.2g %.2g %.2g\r"), init, tSkp[0], tSki[0], tSkd[0])
    serial.fstr4(string("radio %d drive pid:%.2g %.2g %.2g\r"), init, tDkp[0], tDki[0], tDkd[0])
  ' set override max output speed
  omax[0] := omax[1] := swervechannels[CHANNEL_OFF]
  swerve.setpidconstants(@tSkp, @tSki, @tSkd, @tDkp, @tDki, @tDkd, @omax)

PRI runsensors() | count, sbustime, period_time, Acq_time, Acq_time1, compute_time, compute_time1, havepmw, haveusfsmax, havegps, sbusstatus, lsbusstatus, ch, lastx_l, lastx_h, lasty_l, lasty_h, lasto[4], debugo, delaystart, gpsret, gpsrel, xl, yl, oldvoltage, volt, s

  ' init optical flow sensor
  ifnot pmw.begin(PMW_CS, PMW_SCK, PMW_SDO, PMW_SDI) == false
    havepmw := true
  if debugoutput(havepmw?UTILITIES.DEBUGOUT3:UTILITIES.DEBUGOUT1)
    serial.fstr1(string("PMW3901%sfound\r"), havepmw?string(" "):string(" not "))

  waitms(5)
  if havepmw
    pmw.set_orientation(PMW_X_INVERT, PMW_Y_INVERT, PMW_XY_SWAP)
    if PMW_LED
      pmw.setLed(PMW_LED)
    pmw.readMotionAccum(true)                           ' reset accumulator

  ' init IMU
  ifnot (Acq_time := usfsmax.startx(USFSMAX_SCL, USFSMAX_SDA, USFSMAX_RESET, @Config, yawoffset)) == 0
    if debugoutput(UTILITIES.DEBUGOUT1)
      case_fast Acq_time
        $01: serial.fstr1(string("USFSMAX I2C bus error %x\r"), Acq_time)
        $02: serial.fstr1(string("USFSMAX not found %x\r"), Acq_time)
        other: serial.fstr1(string("USFSMAX error %x\r"), Acq_time)
  else
    if debugoutput(UTILITIES.DEBUGOUT3)
      serial.fstr0(string("USFSMAX found\r"))
    haveusfsmax := true

  ' init RC receiver
  sbus.start(SBUS_RX, @Defaults)                        ' start s.bus rx
  waitms(100)
  sbus.reset_count()                                    ' reset frames received count
  sport.start(SBUS_SPORT, SPORT_PHYSICAL_ID)            ' start telemetry channel to transmitter

  if (Acq_time := gps.start(GPS_SCL, GPS_SDA)) == 0
    havegps := true
  if debugoutput(havegps?UTILITIES.DEBUGOUT3:UTILITIES.DEBUGOUT1)
    serial.fstr2(string("GPS%sfound %x\r"), havegps?string(" "):string(" not "), Acq_time)

  battery.start(BATTERY_ANALOG, BATTERY_LOW, BATTERY_HIGH)

  delaystart := getms()

  repeat
    count++
    waitms((SENSORPERIOD - (getms() - delaystart)) #> 1) ' max delay SENSORPERIOD, reduced by debug printing time

    period_time := getms()
    ' read sensors into local variables
    sensorupdate := 0
    ' any channel to tx sbus?
    lsbusstatus := 0
    if sbus.in_failsafe()
      lsbusstatus := FAILSAFE
    elseifnot sbus.has_signal()
      lsbusstatus := LOST
    else
      lsbusstatus := OK
    'takeprintlock()
    'serial.fstr0(string("radio raw: "))
    repeat ch from 0 to NOCHANNELS-1
      if lsbusstatus == OK
        sbuschannels[ch] := utilities.map(s := sbus.read(ch+1), MINSBUSCHANNEL, MAXSBUSCHANNEL, minmap[ch], maxmap[ch])
        'serial.fstr1(string("%d "), s)
      else
        sbuschannels[ch] := Defaults[ch]                ' use defaults if not ok, defaults are post-mapped
    if utilities.longcomp(@lastchannels, @sbuschannels, NOCHANNELS, 2, false) ' not updating lastchannels since we use them later
      sensorupdate |= CHANNELCHANGE                     ' radio channel changed
    if lsbusstatus <> sbusstatus\lsbusstatus
      sbustime := getms()
      sensorupdate |= (CHANNELSTATE | CHANNELCHANGE)
    'serial.fstr0(string("\r"))
    'releaseprintlock()                                  ' release lock soon as we have finished printing

    ' optical flow sensor
    if havepmw
      'takeprintlock()
      Acq_time := getct()
      ch, xl, yl := pmw.readMotionCountBurstQuick()       ' acquire 24us (4Mhz)
      xsensor_l, xsensor_h, ysensor_l, ysensor_h, tsensor := pmw.readMotionAccum(false)
      Acq_time := getct() - Acq_time - 40
      sport.setflow(@xl)                                 ' optical flow telemetry
      'releaseprintlock()                                ' release lock soon as we have finished printing
      if ch && utilities.longcomp(@lastx_l, @xsensor_l, 4, 0, ch)
        sensorupdate |= PMWCHANGE                       ' pmw changed

    ' IMU
    if haveusfsmax
      'takeprintlock()
      Acq_time1 := getct()
      _, qt[0], qt[1], qt[2], qt[3] := usfsmax.getMin() ' 242us (3.0MHz)
      Acq_time1 := getct() - Acq_time1 - 40
      'compute_time1 := getct()
      ' 89us (200MHz)
      'osensor1[YAW], osensor1[PITCH], osensor1[ROLL], osensor1[PRESSURE] := usfsmax.computeIMUFloat(qt[0], qt[1], qt[2], qt[3])
      'compute_time1 := getct() - compute_time1 - 40
      compute_time := getct()
      ' 56us (200MHz)
      osensor[YAW], osensor[PITCH], osensor[ROLL], osensor[PRESSURE] := usfsmax.computeIMUFixed(qt[0], qt[1], qt[2], qt[3])
      compute_time := getct() - compute_time - 40
      'releaseprintlock()                                ' release lock soon as we have finished printing
      sport.setimu(osensor[YAW], osensor[PITCH], osensor[ROLL], osensor[PRESSURE]) ' imu telemetry
      if utilities.longcompf(@lasto, @osensor, 4, true)
        sensorupdate |= IMUCHANGE                       ' imu changed

    if havegps
      'takeprintlock()
      'serial.fstr0(string("gps input\r"))
      if (gpsret := gps.input()) <> 0
        ohour, omin, osec, onorthdeg, owestdeg, ospeed, oalt, gpsrel, ofix, osatno, ohdop := gps.gps()
        sport.setgps(onorthdeg, owestdeg, ospeed, oalt, ofix, osatno, ohdop)
        ogpst |= gpsret
        sensorupdate |= GPSCHANGE                       ' GPS changed
        'serial.fstr0(string("gps input changed\r"))
      'releaseprintlock()                                ' release lock soon as we have finished printing

    ovoltage := float((BATTERY_TEST == true)?27000 + (++volt // (BATTERY_HIGH-27000)):battery.read())/.BATTERY_DIVIDER
    sport.setvoltage(ovoltage)                          ' battery voltage telemetry
    if utilities.frel(fabs(ovoltage -. oldvoltage), 0.2, UTILITIES.FGT)
      oldvoltage := ovoltage
      sensorupdate |= VOLTAGECHANGE

    takesynclock()
    longmove(@sharedupdate, @sensorupdate, SHAREDVARIABLES) ' copy local to shared variables
    releasesynclock()

    delaystart := getms()                               ' print delays are part of sensor delay
    ' print any changes if debutoutput enabled
    if debugoutput(UTILITIES.DEBUGOUT1)
      takeprintlock()
      if sensorupdate & PMWCHANGE
        if debugoutput(UTILITIES.DEBUGOUT3)
          serial.fstr6(string("PMW3901 x:%d:%d y:%d:%d t:%d a:%d\r"), xsensor_h, xsensor_l, ysensor_h, ysensor_l, tsensor, Acq_time/US_001)
      if sensorupdate & IMUCHANGE                       ' imu changed
        if debugoutput(UTILITIES.DEBUGOUT3)
          'serial.fstr4(string("USFSMAX QUAT %.2g %.2g %.2g %.2g\r"), qt[0], qt[1], qt[2], qt[3])
          serial.fstr4(string("USFSMAX Yaw: %.2g, Pitch: %.2g, Roll: %.2g, Pressure: %.2ghPa\r"), osensor[YAW], osensor[PITCH], osensor[ROLL], osensor[PRESSURE])
          serial.fstr2(string("USFSMAX acq: %d compute: %d \r"), Acq_time1/US_001, compute_time/US_001)
          'serial.fstr4(string("USFSMAX1 Yaw: %.2g, Pitch: %.2g, Roll: %.2g, Pressure: %.2ghPa\r"), osensor1[YAW], osensor1[PITCH], osensor1[ROLL], osensor1[PRESSURE])
          'serial.fstr2(string("USFSMAX1 acq: %d compute: %d \r"), Acq_time1/US_001, compute_time1/US_001)
      if sensorupdate & CHANNELSTATE
        if debugoutput(UTILITIES.DEBUGOUT3)
          case_fast sbusstatus
            OK: serial.str(string("Online"))
            FAILSAFE: serial.str(string("Failsafe"))
            LOST: serial.str(string("Frame Lost"))
            other: serial.str(string("Unknown"))
          serial.fstr3(string(" %d %d %d\r"), count, sbustime, sbus.count())
      ' if channel values have changed
      if sensorupdate & CHANNELCHANGE
        if debugoutput(UTILITIES.DEBUGOUT3)
          serial.fstr1(string("Radio (%d): "), count)
          repeat ch from 0 to NOCHANNELS-1
            serial.fstr2(string("%d(%d) "), sbuschannels[ch], sbuschannels[ch]-lastchannels[ch]) ' channel value and delta from previous value
          serial.fstr0(string("\r"))
      if sensorupdate & GPSCHANGE
        if debugoutput(fix == 0?UTILITIES.DEBUGOUT3:UTILITIES.DEBUGOUT4)
          serial.fstr5(string("GPS (%s) %x %2.2d:%2.2d:%+4.8g "), gpsrel, ogpst, ohour, omin, osec)
          serial.fstr2(string("%8.5g %10.5g "), onorthdeg, owestdeg)
          serial.fstr4(string("%.4g %.4g %d %d\r"), ospeed, oalt, fix, satno)

      if sensorupdate & VOLTAGECHANGE
        if debugoutput(UTILITIES.DEBUGOUT3)
          serial.fstr1(string("Voltage %.2g\r"), ovoltage)
        if ovoltage < BATTERY_MINIMUM
          serial.fstr1(string("Minimum Voltage reached %.2g\r"), ovoltage)
          sbus.stop()                                   ' stop the sbus cog
          stopped := true
          quit                                          ' stop this cog

      if debugoutput(UTILITIES.DEBUGOUT4)
        serial.fstr1(string("Sensor period %d\r"), getms()-period_time)
      releaseprintlock()                                ' release lock soon as we have finished printing
    ' need to update lastchannels since we didn't when we did the compare
    if sensorupdate & CHANNELCHANGE
      longmove(@lastchannels, @sbuschannels, NOCHANNELS)

PRI debugoutput(type) : retv
  retv := utilities.debugoutput(debug1, type)

PRI takeprintlock()
  repeat until locktry(printlock) == true               ' take printing lock if we are generating debug output.
    waitus(1)

PRI releaseprintlock()
  lockrel(printlock)

PRI takesynclock()
  repeat until locktry(synclock) == true                ' make sure shared variables are not being used
    waitus(1)

PRI releasesynclock()
  lockrel(synclock)

DAT
  ' default channel values, after mapping
  '                     X  Y   OFF   R
  '                     1  2    3    4
  Defaults      word    0, 0,   0,   0
  '                            Kp                                 Ki                                Kd
  '                            5                                  6                                 7
                word    trunc(-0.0*.PIDCONSTANTSDIVIDER100), trunc(-0.0*.PIDCONSTANTSDIVIDER100), trunc(-0.0*.PIDCONSTANTSDIVIDER1000)
  '                        D1        D2        D3
  '                         8         9        10
                word    MINDEBUG, MINDEBUG, MINDEBUG
  '                      11    12    13    14    15    16    17    18
                word      0,    0,    0,    0,    0,    0,    0,    0
  ' minimum sbus mapping
  '                            Y                 X                T                R
  minmap        long    -swerve.MAXSPEED, -swerve.MAXSPEED,       0,        -swerve.MAXSPEED
                long    MINPIDCONSTANT, MINPIDCONSTANT, MINPIDCONSTANT
                long    MINDEBUG, MINDEBUG, MINDEBUG
                long    MINDEFAULT, MINDEFAULT, MINDEFAULT, MINDEFAULT, MINDEFAULT, MINDEFAULT, MINDEFAULT, MINDEFAULT
  ' maximum sbus mapping
  '                            Y                 X                T                R
  maxmap        long     swerve.MAXSPEED,  swerve.MAXSPEED, swerve.MAXSPEED, swerve.MAXSPEED
                long    MAXPIDCONSTANT, MAXPIDCONSTANT, MAXPIDCONSTANT
                long    MAXDEBUG, MAXDEBUG, MAXDEBUG
                long    MAXDEFAULT, MAXDEFAULT, MAXDEFAULT, MAXDEFAULT, MAXDEFAULT, MAXDEFAULT, MAXDEFAULT, MAXDEFAULT

  ' size of bot:        width  length
  bot           long    12.0,  15.0

  ' yaw offset for usfsmax to front bot in 0-360.0 degrees
  yawoffset     long    1.0

  ' following data needs to be 1 per swerve module, i.e, 1 per NO_SWERVE_MODULES
  ' angle offsets of each swerve module encoder, 0-MAXANGLE
  ' to find value, point each swerve wheel forward, look at encoder debugoutput for raw, map and out
  ' raw is encoder pwm, map is pwm mapped to angle 0-MAXANGLE, out is + encoder offset mod MAXANGLE
  ' pin and angle offsets in order FL, FR, BL, BR
  ' setup so gear on drive wheel are inside on both left and right, so right steering is 180 degree more than encoder
  angleoffsets  long    round((37.96*.float(swerve.MAXANGLE))/.360.0), round((343.82*.float(swerve.MAXANGLE))/.360.0)
                long    round((240.11*.float(swerve.MAXANGLE))/.360.0), round((286.38*.float(swerve.MAXANGLE))/.360.0)

  '   encoder min/max encoder values FL, FR, BL, BR
  '                           spec:   0.9-1.1us       3686-4506us
  '                         actual: 0.98-1.01us 4020.35-4156.13us
  minencoder    long   MININCLK * (CLK_FREQ / 100_000_000), MININCLK * (CLK_FREQ / 100_000_000)
                long   MININCLK * (CLK_FREQ / 100_000_000), MININCLK * (CLK_FREQ / 100_000_000)
  maxencoder    long   MAXINCLK * (CLK_FREQ / 100_000_000), MAXINCLK * (CLK_FREQ / 100_000_000)
                long   MAXINCLK * (CLK_FREQ / 100_000_000), MAXINCLK * (CLK_FREQ / 100_000_000)

  ' encoder pin offsets in order of FL, FR, BL, BR
  pinoffsets    long    3, 1, 2, 0

  '                        FL,    FR     BL     BR
  defaultSteerKp long    -16.0, -16.0, -16.0, -16.0
  defaultSteerKi long    -30.0, -30.0, -30.0, -30.0
  defaultSteerKd long     -0.1,  -0.1,  -0.1,  -0.1

  '                        FL,    FR     BL     BR
  defaultDriveKp long    -16.0, -16.0, -16.0, -16.0
  defaultDriveKi long    -30.0, -30.0, -30.0, -30.0
  defaultDriveKd long     -0.1,  -0.1,  -0.1,  -0.1

  ' 1 per motor, i.e., 2 motors per NO_SWERVE_MODULES
  ' match how motors are connected to the motor driver boards
  ' motor channels 0-3 on board 1, 4-7 on board 2
  '                     FL    FR    BL    BR
  '                     D  S  D  S  D  S  D  S
  motoroffsets  long    7, 6, 3, 2, 4, 5, 0, 1

  ' whether each motor is inverted
  ' setup so gear on drive wheel are inside on both left and right
  '                      FL    FR    BL    BR
  '                     D  S  D  S  D  S  D  S
  invert        word    0, 1, 1, 1, 1, 0, 0, 0

  ' drive motor encoders - speed of drive motors, 7 rises of a pin per motor rotation
  '  plus 1:3 (planetary) * 1:2 (bevel) * 12:30 (center) = 1:15 -> 105 ticks per wheel rotation
  '                            FL                FR                 BL                 BR
  driveencoders long     DRIVEENCODER1A,   DRIVEENCODER2A,    DRIVEENCODER3A,    DRIVEENCODER4A           ' a pin
                long     DRIVEENCODER1B,   DRIVEENCODER2B,    DRIVEENCODER3B,    DRIVEENCODER4B           ' b pin

  ' usfsmax configuration
  Config
                LONG M_V
                LONG M_H
                LONG MAG_DECLINIATION
                byte QUAT_DIV
'