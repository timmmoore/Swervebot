{Swerve bot
                timmoore

  3S lithium battery
        -> 5V regulator -> propeller 2
                -> debug serial to PC (tx(62), rx(63))
                -> 1x radio (sbus_in(7), SPORT(6), sbus_out(5), 5V, Gnd)
                      FrSky R-XSR
                      SPORT sends telemetry: GPS, yaw, pitch, roll, speed/angle of each swerve module battery voltage, temperatures, optical flow
                -> 2x motor driver (SCL(22), SDA(23), Vio, Gnd)
                      I2C motor drivers with PCA9865 and 2x TN6612
                      https://www.tindie.com/products/cburgess129/quad-motor-servo-shield-for-wireless-dev-board/
                      motor is rev HD motor 6000 rpm free speed, quadrature encoder 28 counts/rev
                                drive :gearing 1:3 planetary, 12:30 to drive leg, 1:2 wheel bevel -> 1:15
                                       400 rpm @ wheel, wheel is 2" diameter -> 2500 in/min -> ground speed is 3.5 ft/sec
                                steering: gearing 1:3, 1:4 planetary, 10:40 -> 1:48
                                       absolute angle encoder
                -> 4x encoder (5V, Gnd, pwm(8, 9, 10, 11))
                      https://store.ctr-electronics.com/srx-mag-encoder/
                -> USFSMax (SCL(20), SDA(21), Vio, Gnd)
                      https://www.tindie.com/products/onehorse/usfsmax-module-and-carrier/
                -> GPS PA1010D (SCL(25), SDA(24), Vio, Gnd)
                      https://www.adafruit.com/product/4415
                -> PMW3901 (CS(19), SCK(18), SO(17), SI(15), Vio, Gnd)
                      https://shop.pimoroni.com/products/pmw3901-optical-flow-sensor-breakout?variant=27869870358611
                -> Battery Voltage (31), 8K2, 3K resistor network
                -> 4x quadrature encoders (Gnd, 3V3, A (14, 12, 3, 1), B (15, 13, 2, 0)), 1:3, 12:30, 1:2 -> 1:15
                      7 ticks or 28 count/rev
                -> 4X Temperature sensors TMP36, 1 per motor driver (Gnd, 3V3, 26, 27, 28, 20)
                -> 1x fan with mosfet (Gnd, 3V3, 30)

TODO
  Map USFSMax yaw angle to bot rotation
        User specifies deg/sec and translated to yaw angle deg/sec
  Map pwm3901 x, y to bot x, y
        user specifies x,y/sec and translated to optical x,y/sec
        How does rotation translate to x,y change
                80mm from ground, angle of 42deg
                distance = (sensor value * 80mm)/(sensor resolution * scalar) * 2.0 * tan(42/2)

}

con { timing }

  CLK_FREQ = 200_000_000                                                        ' system freq as a constant
  MS_001   = CLK_FREQ / 1_000                                                   ' ticks in 1ms
  US_001   = CLK_FREQ / 1_000_000                                               ' ticks in 1us

  DEBUG_LOG_SIZE = 500_000

  'BR_SERIAL = 115_200                                                           ' terminal baud rate

  _clkfreq = CLK_FREQ                                                           ' set system clock

con { fixed io pins }

  RX1                           = 63  { I }                                     ' programming / debug
  TX1                           = 62  { O }

                                                                                ' note CS/CLK switched between SD card and flash
  SF_CS                         = 61  { O }                                     ' serial flash
  SF_SCK                        = 60  { O }
  SF_SDO                        = 59  { O }
  SF_SDI                        = 58  { I }

  SD_SCK                        = 61  { O }                                     ' sd card
  SD_CS                         = 60  { O }
  SD_SDI                        = 59  { O }
  SD_SDO                        = 58  { I }

'  WIFI_RES_PIN                  = 56                                            ' pins when using WX WIFI adapter
'  WIFI_PGM_PIN                  = 57
  'WIFI_DI_PIN                   = 62
  'WIFI_DO_PIN                   = 63

'  LED_56                        = 56                                            ' leds on P2 edge board
'  LED_57                        = 57                                            ' disable via switch on board

  NOCHANNELS                    = 18                                            ' number of RC channels

  CHANNEL_X                     = 1                                             ' 1 - x speed
  CHANNEL_Y                     = 0                                             ' 2 - y speed
  CHANNEL_R                     = 3                                             ' 3 - rotate speed
  CHANNEL_OFF                   = 2                                             ' 4 - throttle/disable motors
  CHANNEL_KP                    = 4                                             ' 5 - pid Kp LS
  CHANNEL_KI                    = 5                                             ' 6 - pid Ki RS
  CHANNEL_KD                    = 6                                             ' 7 - pid Kd S1
  CHANNEL_DEBUG1                = 7                                             ' 8 - debug values sa
  CHANNEL_DEBUG2                = 8                                             ' 9                sb
  CHANNEL_DEBUG3                = 9                                             ' 10               sc
  CHANNEL_10                    = 10                                            ' 11 - not used, S2
  CHANNEL_PIDSELECT             = 11                                            ' 12 - pid adjustment selector sd
  CHANNEL_AUTO                  = 12                                            ' 13 - auto roam
  CHANNEL_13                    = 13                                            ' 14 - not used
  CHANNEL_14                    = 14                                            ' 15 - not used
  CHANNEL_15                    = 15                                            ' 16 - not used
  CHANNEL_16                    = 16                                            ' 17 - not used
  CHANNEL_17                    = 17                                            ' 18 - not used

  MINDELTA                      = 5                                             ' minimum channel change

  SBUS_RX                       = 7                                             ' rx channels from transmitter
  SBUS_SPORT                    = 6                                             ' bi-directional: poll from receiver, send sensor values
  SBUS_TX                       = 5                                             ' not used

  MOTOR_SDA                     = 23                                            ' i2c pins for motor controllers
  MOTOR_SCL                     = 22                                            ' SCK speed of 1000KHz

  ENCODERPIN1                   = 8                                             ' pwm encoder pins, must be contiguous pins
  ENCODERPIN2                   = 9
  ENCODERPIN3                   = 10
  ENCODERPIN4                   = 11

  DRIVEENCODER1A                = 15                                            ' FL
  DRIVEENCODER1B                = 14
  DRIVEENCODER2A                = 3                                             ' FR
  DRIVEENCODER2B                = 2
  DRIVEENCODER3A                = 13                                            ' BL
  DRIVEENCODER3B                = 12
  DRIVEENCODER4A                = 1                                             ' BR
  DRIVEENCODER4B                = 0

  ' min 98-101 max:402035-415613
  ' if use spec ranges then error bar is 20-30% which causes large 'deadband' around 0 and the pids oscillate
  ' using actual ranges which have error of 2-3%, much smaller 'deadband'
  MININCLK                      = 98                    '90                     ' min encoder PWM width 0.9-1.1us * 100
  MAXINCLK                      = 415600                '450600                 ' max encoder PWM width 3696-4506us * 100

  'PMW_VCC   = 3.3V
  'PMW_GND
  PMW_CS                        = 19  { O, 3.3V level }                         ' spi pins for optical flow sensor
  PMW_SCK                       = 18  { O, 3.3V level }                         ' SCK speed of 4Mhz
  PMW_SDO                       = 17  { O, 3.3V level }
  PMW_SDI                       = 16  { I, 3.3V level }

  PMW_X_INVERT                  = false                                         ' default init orientation
  PMW_Y_INVERT                  = true
  PMW_XY_SWAP                   = true                                          ' swap x and y axis
  PMW_LED                       = false                                         ' default config is led on

  ' USFSMAX_VCC = 3.3V
  ' USFSMAX_GND
  USFSMAX_SDA                   = 21                                            ' i2c pins for IMU
  USFSMAX_SCL                   = 20                                            ' different I2C bus from motor driver as supports much faster clock speed
                                                                                ' SLK speed of 3.4Mhz
  USFSMAX_RESET                 = -1                                            ' reset pin is optional

  BATTERY_ANALOG                = 31                                            ' battery via resistor divider, 8K2 + 3K3
  BATTERY_LOW                   = 0
  BATTERY_HIGH                  = 33750 '33482                                  ' 8K2 + 3K resistor divider, max voltage is 12.6V * 3000/11200 -> 3.375
  BATTERY_DIVIDER               = 2673.534 '2678.56                             ' 33750/2678.56 -> 12.6, absolute max is 4.2V per cell (total 12.6V)
                                                                                ' 33750/2673.534 -> 12.624
  BATTERY_MINIMUM               = 9.9                                           ' minimum voltage, absolute min is 3.2V per cell (total 9.6V)
  BATTERYDELTA                  = 0.2
  BATTERY_MIN_STOP              = true                                          ' stop the bot if battery is too low

  TEMP_ANALOG1                  = 26                                            ' pin 26-29, TMP36,  0.5 + 25 * 0.01 -> .75V = 25C
  TEMP_ANALOG2                  = 27                                            ' pin 26-29, TMP36,  0.5 + 25 * 0.01 -> .75V = 25C
  TEMP_ANALOG3                  = 28                                            ' pin 26-29, TMP36,  0.5 + 25 * 0.01 -> .75V = 25C
  TEMP_ANALOG4                  = 29                                            ' pin 26-29, TMP36,  0.5 + 25 * 0.01 -> .75V = 25C
  TEMP_LOW                      = -5000                                         ' 0V -> -50C
  TEMP_HIGH                     = 28000                                         ' 3.3V -> 280C
  TEMP_MAX                      = 12000                                         ' TB6612 thermal shutdown is at 150C, though sensor is external so lower
  TEMP_MIN                      = 9000
  TEMPDELTA                     = 100                                           ' * 0.01deg
  TEMP_MAX_STOP                 = true                                          ' stop motors if temp is too high

  ' Bellevue, WA 98008
  M_V                           = 49.4643
  M_H                           = 19.0285
  MAG_DECLINIATION              = 15.2473
  QUAT_DIV                      = $07

  PITCH                         = 0
  ROLL                          = 1
  YAW                           = 2
  PRESSURE                      = 3

  GPS_SDA                       = 24                                            ' PA1010D I2C GPS - 400KHz/3.4MHz clock speed
  GPS_SCL                       = 25

  #1, OK, FAILSAFE, LOST                                                        ' SBUS states

  MOTOR_FAN_PIN                 = 30                                            ' turn motor driver fan on (high)/off (low)

  SENSORPERIOD                  = 50                                            ' ms between sensor query
  SWERVEPERIOD                  = 20                                            ' ms between RC receiver/swerve motor updates

  CHANNELCHANGE                 = $01                                           ' radio state change
  CHANNELSTATE                  = $02                                           ' radio channel change
  PMWCHANGE                     = $04                                           ' pmw
  IMUCHANGE                     = $08                                           ' imu
  GPSCHANGE                     = $10                                           ' gps
  VOLTAGECHANGE                 = $20
  TEMPCHANGE                    = $40
  LIDARCHANGE                   = $80

  PIDSTEER                      = true
  PIDCONSTANTSDIVIDER10         = 10.0
  PIDCONSTANTSDIVIDER100        = 100.0
  PIDCONSTANTSDIVIDER1000       = 1000.0
  MINPIDCONSTANT                = -1000                                         ' PID constants are in range +-4.0
  MAXPIDCONSTANT                = 1000

  MINSBUSCHANNEL                = 172
  MAXSBUSCHANNEL                = 1810
  MIDSBUSCHANNEL                = (MAXSBUSCHANNEL+MINSBUSCHANNEL)/2

  MINDEBUG                      = 500
  MAXDEBUG                      = 2000
  INIT_DEBUG                    = 500

  MINDEFAULT                    = 0
  MIDDEFAULT                    = 500
  MAXDEFAULT                    = 1000

  SHAREDPMW                     = 5                                             ' xsensor_l, xsensor_h, ysensor_l, ysensor_h, tsensor                     '
  SHAREDIMU                     = 4                                             ' osensor
  SHAREDGPS                     = 11                                            ' ogpst, ohour, omin, osec, onorthdeg, owestdeg, ospeed, oalt, ofix, osatno, ohdop
  SHAREVOLTAGE                  = 1
  SHARETEMP                     = 4
  SHAREDVARIABLES               = 1+NOCHANNELS+SHAREDIMU+SHAREDPMW+SHAREDGPS+SHAREVOLTAGE+SHARETEMP+LIDARNOCHANNELS

  NO_SWERVE_MODULES             = 4

  LIDARTX_PIN                   = 56
  LIDARRX_PIN                   = 57
  LIDARCTL_PIN                  = 4
  LIDARNOCHANNELS               = 8

VAR
  ' shared variables
  long synclock, printlock

  long sharedupdate, channels[NOCHANNELS], output[SHAREDIMU], deltax_l, deltax_h, deltay_l, deltay_h, deltat
  long gpst, hour, min, sec, northdeg, westdeg, speed, alt, fix, satno, hdop, voltage, temps[SHARETEMP]
  long lidardistance[LIDARNOCHANNELS]

  ' swerve cog
  long swerveupdate, swervechannels[NOCHANNELS], oswerve[SHAREDIMU], xswerve_l, xswerve_h, yswerve_l, yswerve_h, tswerve   ' swerve cog locals
  long sgpst, shour, smin, ssec, snorthdeg, swestdeg, sspeed, salt, sfix, ssatno, shdop, svoltage, stemps[SHARETEMP]
  long slidardistance[LIDARNOCHANNELS]

  long lastchannels[NOCHANNELS]
  long debug1

  ' sensor cog
  long sensorupdate, sbuschannels[NOCHANNELS], osensor[SHAREDIMU], xsensor_l, xsensor_h, ysensor_l, ysensor_h, tsensor     ' sensor cog locals
  long ogpst, ohour, omin, osec, onorthdeg, owestdeg, ospeed, oalt, ofix, osatno, ohdop, ovoltage, otemps[SHARETEMP]
  long olidardistance[LIDARNOCHANNELS]

  long osensor1[SHAREDIMU]
  long qt[4]
  long stopped                                                  ' stop bot if true
  long motorstopped                                             ' stop motors if true
  long StkAddr[1000]

OBJ
                                                                '  main cog - swerve system
                                                                '  2nd cog - query sensors
  'serial        : "isp_serial_singleton_tmm"
  sbus          : "jm_sbus_rx"                                  ' 1 cog - read sbus from receiver
  sport         : "frskysport"                                  ' 1 cog - handling polling from receiver for telemetry
  swerve        : "swervemotor" | MAX_SWERVE_MODULES=NO_SWERVE_MODULES
  utilities     : "utilities"
  pmw           : "pmw3901"                                     ' Optical flow
  usfsmax       : "usfsmax"                                     ' IMU
  gps           : "gps_pa1010d"                                 ' GPS
  battery       : "jm_ez_analog"                                ' A2D to read battery voltage
  temperature[4] : "temperature"                                ' A2D to read motor driver temperature sensors
  lidar         : "rplidar"                                     ' 1 cog - read lidar
  nn            : "nn_drive"

PUB main() | ch, havemotors, cognum, debug2, debug3, debugo, delaystart, acq_time, again, temp, temp1, speeds[NO_SWERVE_MODULES], aspeeds[NO_SWERVE_MODULES], angles[NO_SWERVE_MODULES], havenn, lidaroutput[2]
  debug1, debug2, debug3 := INIT_DEBUG, INIT_DEBUG, INIT_DEBUG
  longfill(@lastchannels, -1, NOCHANNELS)
  waitms(1000)
  'serial.startx(WIFI_DO_PIN, WIFI_DI_PIN, BR_SERIAL)

  waitms(1000)
  if debugoutput(UTILITIES.DEBUGOUT3)
    debug("Swerve Controller")

  ' lock used to synchronize sensor Input across cogs
  if (synclock := locknew()) < 0
    if debugoutput(UTILITIES.DEBUGOUT1)
      debug("Swerve Controller failed to allocate synclock")
  ' lock used to synchronize printing across cogs
  if (printlock := locknew()) < 0
    if debugoutput(UTILITIES.DEBUGOUT1)
      debug("Swerve Controller failed to allocate printlock")

  swerve.debugconfig(debug2, debug3)
  dopidconstants()

  if havenn := nn.start()
    debug("NN failed to start: ", udec_(havenn))

  ' initialize swerve modules and motors
  if (havemotors := swerve.start(MOTOR_SCL, MOTOR_SDA, ENCODERPIN1, MOTOR_FAN_PIN, @bot, @pinoffsets, @angleoffsets, @minencoder, @maxencoder, @invert, @motoroffsets, @driveencoders))
    if debugoutput(UTILITIES.DEBUGOUT1)
      if havemotors & $01
        debug("Swerve motors I2C bus error ", uhex_(havemotors))
      if havemotors & (swerve.NO_MOTOR1|swerve.NO_MOTOR2)
        debug("Swerve motors not found ", uhex_(havemotors))
  else
    if debugoutput(UTILITIES.DEBUGOUT4)
      debug("Swerve motors found ", uhex_(havemotors))
  swerve.getactuals(@speeds, @aspeeds, @angles)         ' init telemetry to initialized values
  sport.setactuals(@speeds, @aspeeds, @angles, swerve.MAXANGLE) ' swerve speeds/angles telemetry

  cognum := COGSPIN(newcog, runsensors(), @StkAddr)     ' initialize sensors

  delaystart := getms()

  repeat
    waitms(temp := ((SWERVEPERIOD - (getms() - delaystart)) #> 1)) ' max delay SWERVEPERIOD
    if stopped                                          ' bot needs to be stopped
      quit                                              ' leave the repeat and stop cog

    acq_time := getms()
    takesynclock()                                      ' make sure shared variables are not being updated
    longmove(@swerveupdate, @sharedupdate, SHAREDVARIABLES) ' copy shared variables to local copy
    releasesynclock()

    if swerveupdate & CHANNELCHANGE || again            ' use local cog variables and see if any channel changes or swerve modules need updating again
      if debugo := (debugoutput(UTILITIES.DEBUGOUT1) || utilities.debugoutput(debug2, UTILITIES.DEBUGOUT1) || utilities.debugoutput(debug3, UTILITIES.DEBUGOUT1))
        takeprintlock()                                 ' take the print lock if any debug level is on
      delaystart := getms()                             ' delay from after motors updated, debug print delays part of processing time

      if swerveupdate & CHANNELCHANGE                   ' dont need to do this unless channels have changed
        ' update local debug variable before using it
        debug1, debug2, debug3 := swervechannels[CHANNEL_DEBUG1], swervechannels[CHANNEL_DEBUG2], swervechannels[CHANNEL_DEBUG3]
        swerve.debugconfig(debug2, debug3)              ' update remaining debug values through system
        dopidconstants()

      if swerveupdate & LIDARCHANGE                     ' dont need to do this unless lidar has changed
        nn.drive_nn(@slidardistance, @lidaroutput)

      if havemotors <> (swerve.NO_MOTOR1|swerve.NO_MOTOR2) ' update swerve modules with updated movements
        if TEMP_MAX_STOP and motorstopped == true       ' 1 or more temp sensors have reached max temp
          swerve.stopmotors()                           ' disable all motors
        elseif swervechannels[CHANNEL_AUTO] > MIDDEFAULT ' autoroam switch is on
          again := swerve.update(lidaroutput[0], lidaroutput[1], lidaroutput[2], swervechannels[CHANNEL_OFF])
        else
          again := swerve.update(swervechannels[CHANNEL_Y], swervechannels[CHANNEL_X], swervechannels[CHANNEL_R], swervechannels[CHANNEL_OFF])
      swerve.getactuals(@speeds, @aspeeds, @angles)
      sport.setactuals(@speeds, @aspeeds, @angles, swerve.MAXANGLE) ' swerve speeds/angles telemetry
      if debugo
        if debugoutput(UTILITIES.DEBUGOUT4)
          debug("Swerve period ", udec_(temp1 := getms()-acq_time), udec_(temp))
        releaseprintlock()                              ' release lock soon as we have finished printing
      swerveupdate &= CHANNELCHANGE                     ' dont update from channels until sensor cog changes it
    else
      delaystart := getms()                             ' delay from after motors updated, debug print delays still part of processing time
                                                        ' swerve cog is stopping
  swerve.stopmotors()                                   ' stop all motors
  swerve.getactuals(@speeds, @aspeeds, @angles)
  sport.setactuals(@speeds, @aspeeds, @angles, swerve.MAXANGLE) ' update swerve speeds/angles telemetry
  swerve.stop()                                         ' shutdown the swerve modules
  debug("Swerve cog stopped")
  waitms(100)                                           ' let the message out

PRI updatepidconstants(pKp, pKi, pKd) | i
  repeat i from 0 to NO_SWERVE_MODULES-1
    long[pKp][i] := long[pKp][i] +. float(swervechannels[CHANNEL_KP])/.PIDCONSTANTSDIVIDER100
    long[pKi][i] := long[pKi][i] +. float(swervechannels[CHANNEL_KI])/.PIDCONSTANTSDIVIDER100
    long[pKd][i] := long[pKd][i] +. float(swervechannels[CHANNEL_KD])/.PIDCONSTANTSDIVIDER1000

PRI dopidconstants() | tSkp[NO_SWERVE_MODULES], tSki[NO_SWERVE_MODULES], tSkd[NO_SWERVE_MODULES], tDkp[NO_SWERVE_MODULES], tDki[NO_SWERVE_MODULES], tDkd[NO_SWERVE_MODULES], omax[2]
  ' update pid constants
  longmove(@tSkp, @defaultSteerKp, NO_SWERVE_MODULES)   ' start with defaults
  longmove(@tSki, @defaultSteerKi, NO_SWERVE_MODULES)
  longmove(@tSkd, @defaultSteerKd, NO_SWERVE_MODULES)
  longmove(@tDkp, @defaultDriveKp, NO_SWERVE_MODULES)
  longmove(@tDki, @defaultDriveKi, NO_SWERVE_MODULES)
  longmove(@tDkd, @defaultDriveKd, NO_SWERVE_MODULES)
  if swervechannels[CHANNEL_PIDSELECT] < MIDDEFAULT
    updatepidconstants(@tSkp, @tSki, @tSkd)
  else
    updatepidconstants(@tDkp, @tDki, @tDkd)
  if debugoutput(UTILITIES.DEBUGOUT3)
    debug("radio steer pid: ", fdec_(tSkp[0], tSki[0], tSkd[0]), ", drive pid: ", fdec_(tDkp[0], tDki[0], tDkd[0]))
  omax[0] := omax[1] := swervechannels[CHANNEL_OFF]     ' set override max output speed
  swerve.setpidconstants(@tSkp, @tSki, @tSkd, @tDkp, @tDki, @tDkd, @omax)

PRI runsensors() | count, sbustime, period_time, Acq_time, Acq_time1, compute_time, compute_time1, havepmw, haveusfsmax, havegps, sbusstatus, lsbusstatus, ch, lastx_l, lastx_h, lasty_l, lasty_h, lasto[4], debugo, delaystart, gpsret, gpsrel, xl, yl, oldvoltage, volt, s, lasttemps[4], temp, temphigh, templow, lasttemp, lastimu, llidardistance[LIDARNOCHANNELS], havelidar, tlidar[LIDARNOCHANNELS]

  ifnot pmw.begin(PMW_CS, PMW_SCK, PMW_SDO, PMW_SDI) == false ' init optical flow sensor
    havepmw := true
  if debugoutput(havepmw?UTILITIES.DEBUGOUT3:UTILITIES.DEBUGOUT1)
    debug("PMW3901", zstr_(havepmw?@" ":@" not "), "found")
  waitms(5)
  if havepmw
    pmw.set_orientation(PMW_X_INVERT, PMW_Y_INVERT, PMW_XY_SWAP)
    if PMW_LED
      pmw.setLed(PMW_LED)
    pmw.readMotionAccum(true)                           ' reset accumulator

  ifnot (Acq_time := usfsmax.startx(USFSMAX_SCL, USFSMAX_SDA, USFSMAX_RESET, @Config, yawoffset)) == 0 ' init IMU
    if debugoutput(UTILITIES.DEBUGOUT1)
      case_fast Acq_time
        $01: debug("USFSMAX I2C bus error ", uhex_(Acq_time))
        $02: debug("USFSMAX not found ", uhex_(Acq_time))
        other: debug("USFSMAX error ", uhex_(Acq_time))
  else
    if debugoutput(UTILITIES.DEBUGOUT3)
      debug("USFSMAX found")
    haveusfsmax := true

  sbus.start(SBUS_RX, @Defaults)                        ' start s.bus rx
  waitms(50)
  sbus.reset_count()                                    ' reset frames received count
  sport.start(SBUS_SPORT)                               ' start telemetry channel to transmitter

  if (Acq_time := gps.start(GPS_SCL, GPS_SDA)) == 0
    havegps := true
  if debugoutput(havegps?UTILITIES.DEBUGOUT3:UTILITIES.DEBUGOUT1)
    debug("GPS", zstr_(havegps?@" ":@" not "), "found ", uhex_(Acq_time))

  battery.start(BATTERY_ANALOG, BATTERY_LOW, BATTERY_HIGH)

  repeat ch from 0 to SHARETEMP-1                       ' temperature sensors 1 per motor driver TB6612
    temperature[ch].start(TEMP_ANALOG1+ch, TEMP_LOW, TEMP_HIGH)

  lidar.start(LIDARTX_PIN, LIDARRX_PIN, LIDARCTL_PIN)

  lasttemp := delaystart := getms()
  repeat
    count++
    waitms((SENSORPERIOD - (getms() - delaystart)) #> 1) ' max delay SENSORPERIOD, reduced by debug printing time

    period_time := getms()
    ' read sensors into local variables
    sensorupdate := 0
    lsbusstatus := 0                                    ' any channel to tx sbus?
    if sbus.in_failsafe()
      lsbusstatus := FAILSAFE
    elseifnot sbus.has_signal()
      lsbusstatus := LOST
    else
      lsbusstatus := OK
    'takeprintlock()
    'serial.fstr0(string("radio raw: "))
    repeat ch from 0 to NOCHANNELS-1
      if lsbusstatus == OK
        sbuschannels[ch] := utilities.map(s := sbus.read(ch+1), MINSBUSCHANNEL, MAXSBUSCHANNEL, minmap[ch], maxmap[ch])
        'serial.fstr1(string("%d "), s)
      else
        sbuschannels[ch] := Defaults[ch]                ' use defaults if not ok, defaults are post-mapped
    if utilities.longcomp(@lastchannels, @sbuschannels, NOCHANNELS, 2, false) ' not updating lastchannels since we use them later
      sensorupdate |= CHANNELCHANGE                     ' radio channel changed
    if lsbusstatus <> sbusstatus\lsbusstatus
      sbustime := getms()
      sensorupdate |= (CHANNELSTATE | CHANNELCHANGE)
    'serial.fstr0(string("\r"))
    'releaseprintlock()                                  ' release lock soon as we have finished printing

    if havepmw                                          ' optical flow sensor
      'takeprintlock()
      Acq_time := getct()
      ch, xl, yl := pmw.readMotionCountBurstQuick()     ' acquire 24us (4Mhz)
      xsensor_l, xsensor_h, ysensor_l, ysensor_h, tsensor := pmw.readMotionAccum(false)
      Acq_time := getct() - Acq_time - 40
      sport.setflow(@xl)                                ' optical flow telemetry
      'releaseprintlock()                                ' release lock soon as we have finished printing
      if ch && utilities.longcomp(@lastx_l, @xsensor_l, 4, 0, ch)
        sensorupdate |= PMWCHANGE                       ' pmw changed

    if haveusfsmax                                      ' IMU
      'takeprintlock()
      Acq_time1 := getct()
      _, qt[0], qt[1], qt[2], qt[3] := usfsmax.getMin() ' 239us (3.0MHz)
      Acq_time1 := getct() - Acq_time1 - 40
      'compute_time1 := getct()
      ' 89us (200MHz)
      'osensor1[YAW], osensor1[PITCH], osensor1[ROLL], osensor1[PRESSURE] := usfsmax.computeIMUFloat(qt[0], qt[1], qt[2], qt[3])
      'compute_time1 := getct() - compute_time1 - 40
      compute_time := getct()
      ' 56us (200MHz)
      osensor[YAW], osensor[PITCH], osensor[ROLL], osensor[PRESSURE] := usfsmax.computeIMUFixed(qt[0], qt[1], qt[2], qt[3])
      compute_time := getct() - compute_time - 40
      'releaseprintlock()                                ' release lock soon as we have finished printing
      sport.setimu(osensor[YAW], osensor[PITCH], osensor[ROLL], osensor[PRESSURE]) ' imu telemetry
      if utilities.longcompf(@lasto, @osensor, SHAREDIMU, 0.11, true)
        sensorupdate |= IMUCHANGE                       ' imu changed

    if havegps                                          ' gps
      if (gpsret := gps.input()) <> 0
        ohour, omin, osec, onorthdeg, owestdeg, ospeed, oalt, gpsrel, ofix, osatno, ohdop := gps.gps()
        sport.setgps(onorthdeg, owestdeg, ospeed, oalt, ofix, osatno, ohdop)
        ogpst |= gpsret
        sensorupdate |= GPSCHANGE                       ' GPS changed

    if havelidar
      updatelidar()
      if utilities.longcomp(@llidardistance, @olidardistance, LIDARNOCHANNELS, 0, true)
        sensorupdate |= LIDARCHANGE                     ' lidar changed

    if (getms() - lasttemp) > 20                        ' ADCs needs 164us to take a reading
      ovoltage := float(battery.read())/.BATTERY_DIVIDER
      sport.setvoltage(ovoltage)                        ' battery voltage telemetry
      if fabs(ovoltage -. oldvoltage) >. BATTERYDELTA
        oldvoltage := ovoltage
        sensorupdate |= VOLTAGECHANGE

      repeat ch from 0 to SHARETEMP-1
        otemps[ch] := temperature[tempoffsets[ch]].read() ' use temp offset to get temp in FL, FR, BL, BR order
      sport.settemperature(@otemps)                     ' temperature telemetry, 0.01C * 100
      if utilities.longcomp(@lasttemps, @otemps, SHARETEMP, TEMPDELTA, true)
        sensorupdate |= TEMPCHANGE
      lasttemp := getms()

    takesynclock()
    longmove(@sharedupdate, @sensorupdate, SHAREDVARIABLES) ' copy local to shared variables
    releasesynclock()

    delaystart := getms()                               ' print delays are part of sensor delay
    if debugoutput(UTILITIES.DEBUGOUT3) or debugoutput(UTILITIES.DEBUGOUT4) ' print any changes if debutoutput enabled
      takeprintlock()
      if sensorupdate & PMWCHANGE
        if debugoutput(UTILITIES.DEBUGOUT3)
          debug("PMW3901 x:", sdec_(xsensor_h), ":", udec_(xsensor_l), " y:", sdec_(ysensor_h), ":", udec_(ysensor_l), " t:", sdec_(tsensor), " a:", sdec_(Acq_time/US_001))
      if sensorupdate & IMUCHANGE                       ' imu changed
        if debugoutput(UTILITIES.DEBUGOUT3) and (getms() - lastimu) > 1000
          lastimu := getms()
          'serial.fstr4(string("USFSMAX QUAT %.2g %.2g %.2g %.2g\r"), qt[0], qt[1], qt[2], qt[3])
          debug("USFSMAX Yaw: ", fdec_(osensor[YAW]), ", Pitch: ", fdec_(osensor[PITCH]), ", Roll: ", fdec_(osensor[ROLL]), ", Pressure: ", fdec_(osensor[PRESSURE]), "hPa")
          debug("USFSMAX acq: ", sdec_(Acq_time1/US_001), " compute: ", sdec_(compute_time/US_001))
          'serial.fstr4(string("USFSMAX1 Yaw: %.2g, Pitch: %.2g, Roll: %.2g, Pressure: %.2ghPa\r"), osensor1[YAW], osensor1[PITCH], osensor1[ROLL], osensor1[PRESSURE])
          'serial.fstr2(string("USFSMAX1 acq: %d compute: %d \r"), Acq_time1/US_001, compute_time1/US_001)
      if sensorupdate & CHANNELSTATE                    ' radio state change
        if debugoutput(UTILITIES.DEBUGOUT3)
          case_fast sbusstatus
            OK: debug("Online", sdec_(count, sbustime, sbus.count()))
            FAILSAFE: debug("Failsafe", sdec_(count, sbustime, sbus.count()))
            LOST: debug("Frame Lost", sdec_(count, sbustime, sbus.count()))
            other: debug("Unknown", sdec_(count, sbustime, sbus.count()))
      if sensorupdate & CHANNELCHANGE                   ' channel values change
        if debugoutput(UTILITIES.DEBUGOUT3)
          debug("Radio ", sdec_(count), ": ", sdec_long_array_(sbuschannels[ch], NOCHANNELS, sbuschannels[ch]-lastchannels[ch], NOCHANNELS)) ' channel value and delta from previous value
      if sensorupdate & GPSCHANGE                       ' gps change
        if debugoutput(fix == 0?UTILITIES.DEBUGOUT3:UTILITIES.DEBUGOUT4)
          debug("GPS ", zstr_(gpsrel), uhex_(ogpst), sdec_(ohour), ":", sdec_(omin), ":", fdec_(osec), fdec_(onorthdeg), fdec_(owestdeg), fdec_(ospeed), fdec_(oalt), sdec_(fix), sdec_(satno))
      if sensorupdate & VOLTAGECHANGE                   ' battery voltage change
        if debugoutput(UTILITIES.DEBUGOUT3)
          debug("Voltage ", fdec_(ovoltage))
        if ovoltage <. BATTERY_MINIMUM
          debug("Minimum Voltage reached ", fdec_(ovoltage))
          if BATTERY_MIN_STOP                           ' if stop on battery min enabled
            quit                                        ' breakout the repeat, so this cog stops
      if sensorupdate & TEMPCHANGE                      ' temperature sensor change
        if debugoutput(UTILITIES.DEBUGOUT3)
          debug("Temp ", sdec_(lasttemp), " FL:", sdec_(otemps[0]), " FR:", sdec_(otemps[1]), " BL:", sdec_(otemps[2]), " BR:", sdec_(otemps[3]))
        temphigh := templow := 0
        repeat ch from 0 to 3                           ' count number of drivers above max or below min
          if (otemps[ch] > TEMP_MAX)
            temphigh++                                  ' driver too high
            debug("Max Temperature ", sdec_(ch), " reached ", fdec_(otemps[ch]))
          elseif (otemps[ch] < TEMP_MIN)
            templow++                                   ' driver ok
            if motorstopped
              debug("Min Temperature ", sdec_(ch), " reached ", fdec_(otemps[ch]))
        if temphigh and !!motorstopped                  ' at least 1 driver above max, stop the motors
          motorstopped~~
          debug("Stopping motors, driver temps too high ", sdec_(motorstopped))
        elseif templow == 4 and motorstopped            ' all drivers are below min, start the motors
          motorstopped~
          debug("Starting motors, driver temps ok")

      if sensorupdate & LIDARCHANGE                     ' lidar sensor change
        if debugoutput(UTILITIES.DEBUGOUT3)
          debug("Lidar ", fdec_array_(olidardistance, LIDARNOCHANNELS))
        repeat LIDARNOCHANNELS with ch               ' convert to mm for telemetry
          tlidar[ch] := round((1.0 -. olidardistance[ch]) *. float(MAXDISTANCE-MINDISTANCE)) + MINDISTANCE
        sport.setlidar(@tlidar)

      if debugoutput(UTILITIES.DEBUGOUT4)
        debug("Sensor period %d", sdec_(getms()-period_time))
      releaseprintlock()                                ' release lock soon as we have finished printing

    if sensorupdate & CHANNELCHANGE                     ' need to update lastchannels since we didn't when we did the compare
      longmove(@lastchannels, @sbuschannels, NOCHANNELS)
                                                        ' sensor cog is stopping
  stopped := true                                       ' stop main cog
  waitms(100)                                           ' wait to make sure main cog has a chance to complete
  sbus.stop()                                           ' stop the sbus cog
  sport.stop()                                          ' stop the telemetry cog
  debug("Sensor cog stopped")
  waitms(100)                                           ' wait to make sure everything is completed

CON
  INITANGLE     = 90
  INCANGLE      = 45
  DELTAANGLE    = 23                                                            ' +- angle when checking distance
  MINDISTANCE   = 150                                                           ' min distance in mm, 150mm is min lidar can do
  MAXDISTANCE   = 800

PRI updatelidar() | i, angle
  angle := INITANGLE
  repeat LIDARNOCHANNELS with i
    olidardistance[i] := lidar.checkdistance(angle, DELTAANGLE, MINDISTANCE, MAXDISTANCE)
    angle -= INCANGLE
    if angle < 0
      angle := 360

PRI debugoutput(type) : retv
  retv := utilities.debugoutput(debug1, type)

PRI takeprintlock()
  repeat until locktry(printlock) == true               ' take printing lock if we are generating debug output.
    waitus(1)

PRI releaseprintlock()
  lockrel(printlock)

PRI takesynclock()
  repeat until locktry(synclock) == true                ' make sure shared variables are not being used
    waitus(1)

PRI releasesynclock()
  lockrel(synclock)

DAT
  ' default channel values, after mapping
  '                     X  Y   OFF   R
  '                     1  2    3    4
  Defaults      word    0, 0,   0,   0
  '                            Kp                                 Ki                                Kd
  '                            5                                  6                                 7
                word    trunc(0.0*.PIDCONSTANTSDIVIDER100), trunc(0.0*.PIDCONSTANTSDIVIDER100), trunc(0.0*.PIDCONSTANTSDIVIDER1000)
  '                        D1        D2        D3
  '                         8         9        10
                word    MINDEBUG, MINDEBUG, MINDEBUG
  '                      11             12             13    14    15    16    17    18
                word      0,    MINDEFAULT,    MINDEFAULT,    0,    0,    0,    0,    0
  ' minimum sbus mapping
  '                            Y                 X                T                R
  minmap        long    -swerve.MAXSPEED, -swerve.MAXSPEED,       0,        -swerve.MAXSPEED
                long    MINPIDCONSTANT, MINPIDCONSTANT, MINPIDCONSTANT
                long    MINDEBUG, MINDEBUG, MINDEBUG
                long    MINDEFAULT, MINDEFAULT, MINDEFAULT, MINDEFAULT, MINDEFAULT, MINDEFAULT, MINDEFAULT, MINDEFAULT
  ' maximum sbus mapping
  '                            Y                 X                T                R
  maxmap        long     swerve.MAXSPEED,  swerve.MAXSPEED, swerve.MAXSPEED, swerve.MAXSPEED
                long    MAXPIDCONSTANT, MAXPIDCONSTANT, MAXPIDCONSTANT
                long    MAXDEBUG, MAXDEBUG, MAXDEBUG
                long    MAXDEFAULT, MAXDEFAULT, MAXDEFAULT, MAXDEFAULT, MAXDEFAULT, MAXDEFAULT, MAXDEFAULT, MAXDEFAULT

  ' size of bot:        width  length
  bot           long    12.0,  15.0

  ' yaw offset for usfsmax to front bot in 0-360.0 degrees
  yawoffset     long    1.0

  ' following data needs to be 1 per swerve module, i.e, 1 per NO_SWERVE_MODULES
  ' angle offsets of each swerve module encoder, 0-MAXANGLE
  ' to find value, point each swerve wheel forward, look at encoder debugoutput for raw, map and out
  ' raw is encoder pwm, map is pwm mapped to angle 0-MAXANGLE, out is + encoder offset mod MAXANGLE
  ' pin and angle offsets in order FL, FR, BL, BR
  ' setup so gear on drive wheel are inside on both left and right, so right steering is 180 degree more than encoder
  angleoffsets  long    round((358.94*.float(swerve.MAXANGLE))/.360.0), round((332.22*.float(swerve.MAXANGLE))/.360.0)
                long    round((227.81*.float(swerve.MAXANGLE))/.360.0), round((274.21*.float(swerve.MAXANGLE))/.360.0)

  '   encoder min/max encoder values FL, FR, BL, BR
  '                           spec:   0.9-1.1us       3686-4506us
  '                         actual: 0.98-1.01us 4020.35-4156.13us
  minencoder    long   MININCLK * (CLK_FREQ / 100_000_000), MININCLK * (CLK_FREQ / 100_000_000)
                long   MININCLK * (CLK_FREQ / 100_000_000), MININCLK * (CLK_FREQ / 100_000_000)
  maxencoder    long   MAXINCLK * (CLK_FREQ / 100_000_000), MAXINCLK * (CLK_FREQ / 100_000_000)
                long   MAXINCLK * (CLK_FREQ / 100_000_000), MAXINCLK * (CLK_FREQ / 100_000_000)

  ' encoder pin offsets in order of FL, FR, BL, BR
  pinoffsets    long    3, 2, 1, 0

  '                        FL,    FR     BL     BR
  defaultSteerKp long     -4.55, -4.55, -4.55, -4.55
  defaultSteerKi long     -8.53, -8.53, -8.53, -8.53
  defaultSteerKd long     -0.03, -0.03, -0.03, -0.03

  '                        FL,    FR     BL     BR
  defaultDriveKp long    -16.0, -16.0, -16.0, -16.0
  defaultDriveKi long    -30.0, -30.0, -30.0, -30.0
  defaultDriveKd long     -0.1,  -0.1,  -0.1,  -0.1

  ' 1 per motor, i.e., 2 motors per NO_SWERVE_MODULES
  ' match how motors are connected to the motor driver boards
  ' motor channels 0-3 on board 1, 4-7 on board 2
  '                     FL    FR    BL    BR
  '                     D  S  D  S  D  S  D  S
  motoroffsets  long    7, 6, 3, 2, 5, 4, 1, 0
  '                     FL, FR, BL, BR
  tempoffsets   long    3,  1,  2,  0

  ' whether each motor is inverted
  ' setup so gear on drive wheel are inside on both left and right
  '                      FL    FR    BL    BR
  '                     D  S  D  S  D  S  D  S
  invert        word    0, 1, 1, 1, 0, 1, 1, 1

  ' drive motor encoders - speed of drive motors, 7 rises of a pin per motor rotation
  '  plus 1:3 (planetary) * 1:2 (bevel) * 12:30 (center) = 1:15 -> 105 ticks per wheel rotation
  '                            FL                FR                 BL                 BR
  driveencoders long     DRIVEENCODER1A,   DRIVEENCODER2A,    DRIVEENCODER3A,    DRIVEENCODER4A           ' a pin
                long     DRIVEENCODER1B,   DRIVEENCODER2B,    DRIVEENCODER3B,    DRIVEENCODER4B           ' b pin

  ' usfsmax configuration
  Config
                LONG M_V
                LONG M_H
                LONG MAG_DECLINIATION
                byte QUAT_DIV, 0, 0, 0
'
con { license }

{{

  Terms of Use: MIT License

  Permission is hereby granted, free of charge, to any person obtaining a copy of this
  software and associated documentation files (the "Software"), to deal in the Software
  without restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to the following
  conditions:

  The above copyright notice and this permission notice shall be included in all copies
  or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
  CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

}}