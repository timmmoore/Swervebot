{Swerve bot}

{
  3S lithium battery
        -> 2x I2C motor drivers with PCA9865 and 2x TN6612
        -> 5V regulator -> propeller 2
                -> debug serial to PC (tx(62), rx(63))
                -> 1x radio (sbus(55), Vio, Gnd)
                -> 2x motor driver (SCL(56), SDA(57), Vio, Gnd)
                -> 4x encoder (Vio, Gnd, analog(50, 51, 52, 53))
                                mod encoder for 3.3V

TODO
  Map USFSMax yaw angle to bot rotation
        User specifies deg/sec and translated to yaw angle deg/sec
  Map pwm3901 x, y to bot x, y
        user specifies x,y/sec and translated to optical x,y/sec
        How does rotation translate to x,y change
                80mm from ground, angle of 42deg
                distance = (sensor value * 80mm)/(sensor resolution * scalar) * 2.0 * tan(42/2)

}

con { timing }

  CLK_FREQ = 200_000_000                                                        ' system freq as a constant
  MS_001   = CLK_FREQ / 1_000                                                   ' ticks in 1ms
  US_001   = CLK_FREQ / 1_000_000                                               ' ticks in 1us

  BR_SERIAL = 115_200                                                           ' terminal baud rate

  _clkfreq = CLK_FREQ                                                           ' set system clock

con { fixed io pins }

  RX1                           = 63  { I }                                     ' programming / debug
  TX1                           = 62  { O }

  SF_CS                         = 61  { O }                                     ' serial flash
  SF_SCK                        = 60  { O }
  SF_SDO                        = 59  { O }
  SF_SDI                        = 58  { I }

  SD_SCK                        = 61  { O }                                     ' sd card
  SD_CS                         = 60  { O }
  SD_SDI                        = 59  { O }
  SD_SDO                        = 58  { I }

  NOCHANNELS                    = 18                                            ' number of channels

  CHANNEL_X                     = 1                                             ' 1 - x speed
  CHANNEL_Y                     = 0                                             ' 2 - y speed
  CHANNEL_R                     = 3                                             ' 3 - rotate speed
  CHANNEL_OFF                   = 2                                             ' 4 - throttle/disable motors
  CHANNEL_KP                    = 4                                             ' 5 - pid Kp ls
  CHANNEL_KI                    = 5                                             ' 6 - pid Ki rs
  CHANNEL_KD                    = 6                                             ' 7 - pid Kd s1
  CHANNEL_DEBUG1                = 7                                             ' 8 - debug values sa
  CHANNEL_DEBUG2                = 8                                             ' 9                sb
  CHANNEL_DEBUG3                = 9                                             ' 10               sc
  CHANNEL_TESTMAX               = 10                                            ' 11 max output speed s2

  MINDELTA                      = 5                                             ' minimum channel change

  SBUS_RX                       = 7   { IO }

  MOTOR_SDA                     = 23                                            ' i2c pins for motor controllers
  MOTOR_SCL                     = 22                                            ' SCK speed of 800KHz

  ENCODERPIN1                   = 8                                             ' pwm encoder pins, must be contiguous pins
  ENCODERPIN2                   = 9
  ENCODERPIN3                   = 10
  ENCODERPIN4                   = 11

  ' min 98-101 max:402035-415613
  ' if use spec ranges then error bar is 20-30% which causes large 'deadband' around 0 and the pids oscillate
  ' using actual ranges which have error of 2-3%, much smaller 'deadband'
  MININCLK                      = 98 '90                                        ' min encoder PWM width 0.9-1.1us * 100
  MAXINCLK                      = 415600 '450600                                ' max encoder PWM width 3696-4506us * 100

  'PMW_VCC   = 3.3V
  'PMW_GND
  PMW_CS                        = 19  { O, 3.3V level }                         ' spi pins for optical flow sensor
  PMW_SCK                       = 18  { O, 3.3V level }                         ' SCK speed of 4Mhz
  PMW_SDO                       = 17  { O, 3.3V level }
  PMW_SDI                       = 16  { I, 3.3V level }

  PMW_X_INVERT                  = true                                          ' default init orientation
  PMW_Y_INVERT                  = false
  PMW_XY_SWAP                   = false                                          ' swap x and y axis
  PMW_LED                       = false

  ' USFSMAX_VCC = 3.3V
  ' USFSMAX_GND
  USFSMAX_SDA                   = 21                                            ' i2c pins for IMU
  USFSMAX_SCL                   = 20                                            ' different I2C bus from motor driver as supports much faster clock speed
                                                                                ' SLK speed of 3Mhz
  USFSMAX_RESET                 = -1                                            ' reset pin is optional

  ' Bellevue, WA 98008
  M_V                           = 49.4643
  M_H                           = 19.0285
  MAG_DECLINIATION              = 15.2473
  QUAT_DIV                      = $07

  PITCH                         = 0
  ROLL                          = 1
  YAW                           = 2
  PRESSURE                      = 3

  GPS_SDA                       = 24                                            ' PA1010D I2C GPS - 400KHz/3.4MHz clock speed
  GPS_SCL                       = 25

  #1, OK, FAILSAFE, LOST                                                        ' SBUS states

  SENSORPERIOD                  = 50                                            ' ms between sensor query
  SWERVEPERIOD                  = 20                                            ' ms between RC receiver/swerve motor updates

  CHANNELCHANGE                 = $01                                           ' radio state change
  CHANNELSTATE                  = $02                                           ' radio channel change
  PMWCHANGE                     = $04                                           ' pmw
  IMUCHANGE                     = $08                                           ' imu
  GPSCHANGE                     = $10                                           ' gps

  PIDCONSTANTSDIVIDER           = 10.0
  MINPIDCONSTANT                = -400                                          ' PID constants are in range +-40.0
  MAXPIDCONSTANT                = 400

  MINSBUSCHANNEL                = 240
  MAXSBUSCHANNEL                = 1807
  MIDSBUSCHANNEL                = (MAXSBUSCHANNEL+MINSBUSCHANNEL)/2

  MINDEBUG                      = 500
  MAXDEBUG                      = 2000
  INIT_DEBUG                    = 500

  MINTEST                       = 0
  MAXTEST                       = 2000

  MINDEFAULT                    = 0
  MAXDEFAULT                    = 1000

  SHAREDPMW                     = 5                     ' xsensor_l, xsensor_h, ysensor_l, ysensor_h, tsensor                     '
  SHAREDIMU                     = 4                     ' osensor
  SHAREDGPS                     = 10                    ' ogpst, ohour, omin, osec, onorthdeg, owestdeg, ospeed, oalt, ofix, osatno
  SHAREDVARIABLES               = 1+NOCHANNELS+SHAREDIMU+SHAREDPMW+SHAREDGPS

VAR
  ' shared variables
  long synclock, printlock

  long sharedupdate, channels[NOCHANNELS], output[4], deltax_l, deltax_h, deltay_l, deltay_h, deltat
  long gpst, hour, min, sec, northdeg, westdeg, speed, alt, fix, satno

  ' swerve cog
  long swerveupdate, swervechannels[NOCHANNELS], oswerve[4], xswerve_l, xswerve_h, yswerve_l, yswerve_h, tswerve   ' swerve cog locals
  long sgpst, shour, smin, ssec, snorthdeg, swestdeg, sspeed, salt, sfix, ssatno

  long lastchannels[NOCHANNELS]
  long debug1

  ' sensor cog
  long sensorupdate, sbuschannels[NOCHANNELS], osensor[4], xsensor_l, xsensor_h, ysensor_l, ysensor_h, tsensor     ' sensor cog locals
  long ogpst, ohour, omin, osec, onorthdeg, owestdeg, ospeed, oalt, ofix, osatno

  long osensor1[4]
  long qt[4]
  long StkAddr[10000]

OBJ
                                                                '  main cog - swerve system
                                                                '  2nd cog - query sensors
  serial        : "isp_serial_singleton_tmm"
  sbus          : "jm_sbus_rx"                                  ' 1 cog - read sbus
  swerve        : "swervemotor"
  utilities     : "utilities"
  pmw           : "pmw3901"
  usfsmax       : "usfsmax"
  gps           : "gps_pa1010d"

PUB main() | ch, havemotors, cognum, debug2, debug3, debugo, delaystart, acq_time, again, temp, temp1, tkp[4], tki[4], tkd[4]
  debug1, debug2, debug3 := INIT_DEBUG, INIT_DEBUG, INIT_DEBUG
  longfill(@lastchannels, -1, NOCHANNELS)
  serial.start(BR_SERIAL)

  waitms(100)
  if debugoutput(UTILITIES.DEBUGOUT4)
    serial.fstr0(string("Swerve Controller\r"))

  ' lock used to synchronize sensor Input across cogs
  if (synclock := locknew()) < 0
    if debugoutput(UTILITIES.DEBUGOUT1)
      serial.fstr0(string("Swerve Controller failed to allocate synclock\r"))
  ' lock used to synchronize printing across cogs
  if (printlock := locknew()) < 0
    if debugoutput(UTILITIES.DEBUGOUT1)
      serial.fstr0(string("Swerve Controller failed to allocate printlock\r"))

  swerve.debugconfig(debug2, debug3)
  swerve.setpidconstants(@defaultKp, @defaultKi, @defaultKd, Defaults[CHANNEL_TESTMAX])

  ' initialize server modules and motors
  if (havemotors := swerve.start(MOTOR_SCL, MOTOR_SDA, ENCODERPIN1, @bot, @pinoffsets, @angleoffsets, @minencoder, @maxencoder, @invert, @motoroffsets))
    if debugoutput(UTILITIES.DEBUGOUT1)
      if havemotors & $01
        serial.fstr1(string("Swerve motors I2C bus error %x\r"), havemotors)
      if havemotors & (swerve.NO_MOTOR1|swerve.NO_MOTOR2)
        serial.fstr1(string("Swerve motors not found %x\r"), havemotors)

  '' initialize sensors
  cognum := COGSPIN(newcog, runsensors(), @StkAddr)
  waitms(50)

  delaystart := getms()

  repeat
    waitms(temp := ((SWERVEPERIOD - (getms() - delaystart)) #> 1)) ' max delay SWERVEPERIOD
    ' make sure shared variables are not being updated
    ' copy to local variables
    acq_time := getms()
    takesynclock()
    longmove(@swerveupdate, @sharedupdate, SHAREDVARIABLES) ' copy shared variables to local copy
    releasesynclock()
    ' use local variables and see if any channel changes or swerve modules need updating again
    if swerveupdate & CHANNELCHANGE || again
      ' update local debug variable before using it
        debug1, debug2, debug3 := swervechannels[CHANNEL_DEBUG1], swervechannels[CHANNEL_DEBUG2], swervechannels[CHANNEL_DEBUG3]
      ' update remaining debug values through system
        swerve.debugconfig(debug2, debug3)
      ' take the print lock if any debug level is on
      if debugo := (debugoutput(UTILITIES.DEBUGOUT1) || utilities.debugoutput(debug2, UTILITIES.DEBUGOUT1) || utilities.debugoutput(debug3, UTILITIES.DEBUGOUT1))
        takeprintlock()
      ' update pid constants, constants are channel values mapped to MINPIDCONSTANT to MAXPIDCONSTANT divided by PIDCONSTANTSDIVIDER
      ' set override max output speed
      'serial.fstr3(string("radio pid:%d %d %d\r"), swervechannels[CHANNEL_KP], swervechannels[CHANNEL_KI], swervechannels[CHANNEL_KD])
      tkp[3] := float(swervechannels[CHANNEL_KP])/.PIDCONSTANTSDIVIDER
      longfill(@tkp, tkp[3], 3)
      tki[3] := float(swervechannels[CHANNEL_KI])/.PIDCONSTANTSDIVIDER
      longfill(@tki, tki[3], 3)
      tkd[3] := float(swervechannels[CHANNEL_KD])/.PIDCONSTANTSDIVIDER
      longfill(@tkd, tkd[3], 3)
      ' disable pid constant updates
      'swerve.setpidconstants(@tkp, @tki, @tkd, swervechannels[CHANNEL_TESTMAX])
      swerve.setpidconstants(@defaultKp, @defaultKi, @defaultKd, swervechannels[CHANNEL_TESTMAX])

      ' update swerve modules with updated movements
      if havemotors <> (swerve.NO_MOTOR1|swerve.NO_MOTOR2)
        again := swerve.update(swervechannels[CHANNEL_X], swervechannels[CHANNEL_Y], swervechannels[CHANNEL_R], swervechannels[CHANNEL_OFF])
      if debugo
        if debugoutput(UTILITIES.DEBUGOUT3)
          serial.fstr2(string("Swerve period %d %d\r"), temp1 := getms()-acq_time, temp)
        releaseprintlock()                              ' release lock soon as we have finished printing
    delaystart := getms()                               ' delay from after motors updated, debug print delays still part of processing time

PRI runsensors() | count, sbustime, period_time, Acq_time, Acq_time1, compute_time, compute_time1, havepmw, haveusfsmax, havegps, sbusstatus, lsbusstatus, ch, lastx_l, lastx_h, lasty_l, lasty_h, lasto[4], debugo, delaystart, gpsret, gpsrel, xl, xh, yl, yh

  ' init optical flow sensor
  ifnot pmw.begin(PMW_CS, PMW_SCK, PMW_SDO, PMW_SDI) == false
    havepmw := true
  if debugoutput(havepmw?UTILITIES.DEBUGOUT3:UTILITIES.DEBUGOUT1)
    serial.fstr1(string("PMW3901%sfound\r"), havepmw?string(" "):string(" not "))

  waitms(5)
  if havepmw
    pmw.set_orientation(PMW_X_INVERT, PMW_Y_INVERT, PMW_XY_SWAP)
    if PMW_LED
      pmw.setLed(PMW_LED)
    pmw.readMotionAccum(true)                               ' reset accumulator

  ' init IMU
  ifnot (Acq_time := usfsmax.startx(USFSMAX_SCL, USFSMAX_SDA, USFSMAX_RESET, @Config, yawoffset)) == 0
    if debugoutput(UTILITIES.DEBUGOUT1)
      case_fast Acq_time
        $01: serial.fstr1(string("USFSMAX I2C bus error %x\r"), Acq_time)
        $02: serial.fstr1(string("USFSMAX not found %x\r"), Acq_time)
        other: serial.fstr1(string("USFSMAX error %x\r"), Acq_time)
  else
    if debugoutput(UTILITIES.DEBUGOUT3)
      serial.fstr0(string("USFSMAX found\r"))
    haveusfsmax := true

  ' init RC receiver
  sbus.start(SBUS_RX, @Defaults)                        ' start s.bus rx
  waitms(100)
  sbus.reset_count()                                    ' reset frames received count

  if (Acq_time := gps.start(GPS_SCL, GPS_SDA)) == 0
    havegps := true
  if debugoutput(havegps?UTILITIES.DEBUGOUT3:UTILITIES.DEBUGOUT1)
    serial.fstr2(string("GPS%sfound %x\r"), havegps?string(" "):string(" not "), Acq_time)
  delaystart := getms()

  repeat
    count++
    waitms((SENSORPERIOD - (getms() - delaystart)) #> 1) ' max delay SENSORPERIOD, reduced by debug printing time

    period_time := getms()
    ' read sensors into local variables
    sensorupdate := 0
    ' any channel to tx sbus?
    lsbusstatus := 0
    if sbus.in_failsafe()
      lsbusstatus := FAILSAFE
    elseifnot sbus.has_signal()
      lsbusstatus := LOST
    else
      lsbusstatus := OK
    repeat ch from 0 to NOCHANNELS-1
      if lsbusstatus == OK
        sbuschannels[ch] := utilities.map(sbus.read(ch+1), MINSBUSCHANNEL, MAXSBUSCHANNEL, minmap[ch], maxmap[ch])
      else
        sbuschannels[ch] := Defaults[ch]                ' use defaults if not ok, defaults are post-mapped
    if utilities.longcomp(@lastchannels, @sbuschannels, NOCHANNELS, 2, false) ' not updating lastchannels since we use them later
      sensorupdate |= CHANNELCHANGE                     ' radio channel changed
    if lsbusstatus <> sbusstatus\lsbusstatus
      sbustime := getms()
      sensorupdate |= (CHANNELSTATE | CHANNELCHANGE)

    ' optical flow sensor
    if havepmw
      takeprintlock()
      Acq_time := getct()
      ch, _, _ := pmw.readMotionCountBurstQuick()                   ' acquire 24us (4Mhz)
      xsensor_l, xsensor_h, ysensor_l, ysensor_h, tsensor := pmw.readMotionAccum(false)
      Acq_time := getct() - Acq_time - 40
      'serial.fstr6(string("pmw %d %d %d:%d %d:%d\r"), xsensor_l, ysensor_l, xh, xl, yh, yl)
      releaseprintlock()                                ' release lock soon as we have finished printing
      if ch && utilities.longcomp(@lastx_l, @xsensor_l, 4, 0, ch)
        sensorupdate |= PMWCHANGE                       ' pmw changed

    ' IMU
    if haveusfsmax
      'takeprintlock()
      Acq_time1 := getct()
      _, qt[0], qt[1], qt[2], qt[3] := usfsmax.getMin() ' 242us (3.0MHz)
      Acq_time1 := getct() - Acq_time1 - 40
      'compute_time1 := getct()
      ' 89us (200MHz)
      'osensor1[YAW], osensor1[PITCH], osensor1[ROLL], osensor1[PRESSURE] := usfsmax.computeIMUFloat(qt[0], qt[1], qt[2], qt[3])
      'compute_time1 := getct() - compute_time1 - 40
      compute_time := getct()
      ' 56us (200MHz)
      osensor[YAW], osensor[PITCH], osensor[ROLL], osensor[PRESSURE] := usfsmax.computeIMUFixed(qt[0], qt[1], qt[2], qt[3])
      compute_time := getct() - compute_time - 40
      'releaseprintlock()                                ' release lock soon as we have finished printing
      if utilities.longcompf(@lasto, @osensor, 4, true)
        sensorupdate |= IMUCHANGE                       ' imu changed

    if havegps
      'takeprintlock()
      'serial.fstr0(string("gps input\r"))
      if (gpsret := gps.input()) <> 0
        ohour, omin, osec, onorthdeg, owestdeg, ospeed, oalt, gpsrel, ofix, osatno := gps.gps()
        ogpst |= gpsret
        sensorupdate |= GPSCHANGE                       ' GPS changed
        'serial.fstr0(string("gps input changed\r"))
      'releaseprintlock()                                ' release lock soon as we have finished printing

    takesynclock()
    longmove(@sharedupdate, @sensorupdate, SHAREDVARIABLES) ' copy local to shared variables
    releasesynclock()

    delaystart := getms()                               ' print delays are part of sensor delay
    ' print any changes if debutoutput enabled
    if debugoutput(UTILITIES.DEBUGOUT1)
      takeprintlock()
      if sensorupdate & PMWCHANGE
        if debugoutput(UTILITIES.DEBUGOUT3)
          serial.fstr6(string("PMW3901 x:%d:%d y:%d:%d t:%d a:%d\r"), xsensor_h, xsensor_l, ysensor_h, ysensor_l, tsensor, Acq_time/US_001)
      if sensorupdate & IMUCHANGE                       ' imu changed
        if debugoutput(UTILITIES.DEBUGOUT3)
          'serial.fstr4(string("USFSMAX QUAT %.2g %.2g %.2g %.2g\r"), qt[0], qt[1], qt[2], qt[3])
          serial.fstr4(string("USFSMAX Yaw: %.2g, Pitch: %.2g, Roll: %.2g, Pressure: %.2ghPa\r"), osensor[YAW], osensor[PITCH], osensor[ROLL], osensor[PRESSURE])
          serial.fstr2(string("USFSMAX acq: %d compute: %d \r"), Acq_time1/US_001, compute_time/US_001)
          'serial.fstr4(string("USFSMAX1 Yaw: %.2g, Pitch: %.2g, Roll: %.2g, Pressure: %.2ghPa\r"), osensor1[YAW], osensor1[PITCH], osensor1[ROLL], osensor1[PRESSURE])
          'serial.fstr2(string("USFSMAX1 acq: %d compute: %d \r"), Acq_time1/US_001, compute_time1/US_001)
      if sensorupdate & CHANNELSTATE
        if debugoutput(UTILITIES.DEBUGOUT3)
          case_fast sbusstatus
            OK: serial.str(string("Online"))
            FAILSAFE: serial.str(string("Failsafe"))
            LOST: serial.str(string("Frame Lost"))
            other: serial.str(string("Unknown"))
          serial.fstr3(string(" %d %d %d\r"), count, sbustime, sbus.count())
      ' if channel values have changed
      if sensorupdate & CHANNELCHANGE
        if debugoutput(UTILITIES.DEBUGOUT3)
          serial.fstr1(string("Radio (%d): "), count)
          repeat ch from 0 to NOCHANNELS-1
            serial.fstr2(string("%d(%d) "), sbuschannels[ch], sbuschannels[ch]-lastchannels[ch]) ' channel value and delta from previous value
          serial.fstr0(string("\r"))
      if sensorupdate & GPSCHANGE
        if debugoutput(UTILITIES.DEBUGOUT3)
          serial.fstr5(string("GPS (%s) %x %2.2d:%2.2d:%+4.8g "), gpsrel, ogpst, ohour, omin, osec)
          serial.fstr2(string("%8.5g %10.5g "), onorthdeg, owestdeg)
          serial.fstr4(string("%.4g %.4g %d %d\r"), ospeed, oalt, fix, satno)

      if debugoutput(UTILITIES.DEBUGOUT4)
        serial.fstr1(string("Sensor period %d\r"), getms()-period_time)
      releaseprintlock()                                ' release lock soon as we have finished printing
    ' need to update lastchannels since we didn't when we did the compare
    if sensorupdate & CHANNELCHANGE
      longmove(@lastchannels, @sbuschannels, NOCHANNELS)

PRI debugoutput(type) : retv
  retv := utilities.debugoutput(debug1, type)

PRI takeprintlock()
  repeat until locktry(printlock) == true               ' take printing lock if we are generating debug output.
    waitus(1)

PRI releaseprintlock()
  lockrel(printlock)

PRI takesynclock()
  repeat until locktry(synclock) == true                ' make sure shared variables are not being used
    waitus(1)

PRI releasesynclock()
  lockrel(synclock)

DAT
  ' default channel values, after mapping
  '                     X  Y   OFF   R      Kp  Ki  Kd        D1        D2        D3
  '                     1  2    3    4       5   6   7         8         9        10
  Defaults      word    0, 0,   0,   0,     20,  0,  0,    MINDEBUG, MINDEBUG, MINDEBUG
  '
  '                     11        12    13    14    15    16    17    18
                word   MAXTEST,    0,    0,    0,    0,    0,    0,    0
  ' minimum sbus mapping
  minmap        long    -swerve.MAXSPEED, -swerve.MAXSPEED, 0, -swerve.MAXSPEED
                long    MINPIDCONSTANT, MINPIDCONSTANT, MINPIDCONSTANT
                long    MINDEBUG, MINDEBUG, MINDEBUG
                long    MINTEST, MINDEFAULT, MINDEFAULT, MINDEFAULT, MINDEFAULT, MINDEFAULT, MINDEFAULT, MINDEFAULT
  ' maximum sbus mapping
  maxmap        long    swerve.MAXSPEED, swerve.MAXSPEED, swerve.MAXSPEED, swerve.MAXSPEED
                long    MAXPIDCONSTANT, MAXPIDCONSTANT, MAXPIDCONSTANT
                long    MAXDEBUG, MAXDEBUG, MAXDEBUG
                long    MAXTEST, MAXDEFAULT, MAXDEFAULT, MAXDEFAULT, MAXDEFAULT, MAXDEFAULT, MAXDEFAULT, MAXDEFAULT

  ' size of bot:        width  length
  bot           long    12.0,  15.0

  ' yaw offset for usfsmax to front bot in 0-360.0 degrees
  yawoffset     long    1.0

  ' angle offsets of each swerve module encoder, 0-MAXANGLE
  ' to find value, point each swerve wheel forward, look at encoder debugoutput for raw, map and out
  ' raw is encoder pwm, map is pwm mapped to angle 0-MAXANGLE, out is + encoder offset mod MAXANGLE
  ' pin and angle offsets in order FL, FR, BL, BR
  ' setup so gear on drive wheel are inside on both left and right, so right steering is 180 degree more than encoder
  angleoffsets  long    round((37.96*.float(swerve.MAXANGLE))/.360.0), round((343.82*.float(swerve.MAXANGLE))/.360.0)
                long    round((240.11*.float(swerve.MAXANGLE))/.360.0), round((286.38*.float(swerve.MAXANGLE))/.360.0)
  ' encoder min/max encoder values FL, FR, BL, BR
'                           spec:   0.9-1.1us       3686-4506us
'                         actual: 0.98-1.01us 4020.35-4156.13us
  minencoder    long   MININCLK * (CLK_FREQ / 100_000_000), MININCLK * (CLK_FREQ / 100_000_000)
                long   MININCLK * (CLK_FREQ / 100_000_000), MININCLK * (CLK_FREQ / 100_000_000)
  maxencoder    long   MAXINCLK * (CLK_FREQ / 100_000_000), MAXINCLK * (CLK_FREQ / 100_000_000)
                long   MAXINCLK * (CLK_FREQ / 100_000_000), MAXINCLK * (CLK_FREQ / 100_000_000)

  ' encoder pin offsets in order of FL, FR, BL, BR
  pinoffsets    long    3, 1, 2, 0

  ' match how motors are connected to the motor driver boards
  ' motor channels 0-3 on board 1, 4-7 on board 2
  '                     FL    FR    BL    BR
  '                     D  S  D  S  D  S  D  S
  motoroffsets  long    7, 6, 3, 2, 4, 5, 0, 1

  ' whether each motor is inverted
  ' setup so gear on drive wheel are inside on both left and right
  '                      FL    FR    BL    BR
  '                     D  S  D  S  D  S  D  S
  invert        word    0, 1, 1, 1, 1, 0, 0, 0

  '                       FL,    FR     BL     BR
  defaultKp     long     -8.5,  -8.5,  -8.5,  -8.5
  defaultKi     long    -20.0, -20.0, -20.0, -20.0
  defaultKd     long     -0.1,  -0.1,  -0.1,  -0.1

  Config
                LONG M_V
                LONG M_H
                LONG MAG_DECLINIATION
                byte QUAT_DIV
'