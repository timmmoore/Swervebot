{Object_Title_and_Purpose}

CON
  MAXSPEED      = 4096                                       ' -4096 < 0 < 4096
  MAXANGLE      = 1024                                       ' 0-1024 is 0-360deg, +ve is clockwise, -ve anticlockwise

  MINDRIVESPEED = 10
  MINSTEERINGSPEED = 10

  MAX_SWERVE_MODULES = 4
  MAX_ENCODERS  = MAX_SWERVE_MODULES                         ' 1 per swerve module

  NO_MOTOR1         =           MOTOR.NO_MOTOR1
  NO_MOTOR2         =           MOTOR.NO_MOTOR2

  DEBUG_OUTPUT      =           500

  BOT_WIDTH                     = 0
  BOT_LENGTH                    = 1

  D_FRONT_LEFT                  = 0
  S_FRONT_LEFT                  = 1
  A_FRONT_LEFT                  = 0
  D_FRONT_RIGHT                 = 2
  S_FRONT_RIGHT                 = 3
  A_FRONT_RIGHT                 = 1
  D_BACK_LEFT                   = 4
  S_BACK_LEFT                   = 5
  A_BACK_LEFT                   = 2
  D_BACK_RIGHT                  = 6
  S_BACK_RIGHT                  = 7
  A_BACK_RIGHT                  = 3

VAR
  long speeders[MAX_SWERVE_MODULES*2]   ' 0: drive motor speeds, 1: steering speed for 4 swerve modules
  long angles[MAX_SWERVE_MODULES]       ' angle for 4 swerve modules
  word angleoffsets[MAX_SWERVE_MODULES] ' steering angle offset
  word debug2
  long lastcx, lastcy, lastcr, motorsareoff
  long acctime
  long rad            ' float, diag size of bot
  long bot[2]         ' float bot size, turn around center of bot
  long overridemax

OBJ
  serial        : "isp_serial_singleton_tmm"
  encoder       : "pwm_in" | NOPWMIN = MAX_ENCODERS     ' angle position of each swerve
  pid[MAX_ENCODERS] : "pid"                             ' pid for controling angle of each swerve
  utilities     : "utilities"
  motor         : "motordriver"                         ' motor drivers for drive and steering motors

PUB null()
  ' This is not a top-level object

PUB start(scl, sda, epin, pbot, poffsets, pinvert) : retv | ch, t1, t2
  '' start 4 swerve modules
  longmove(@bot, pbot, 2)                                       ' size of bot
  wordmove(@angleoffsets, poffsets, MAX_SWERVE_MODULES)         ' angle offset of each encoder
  rad := fsqrt(bot[BOT_WIDTH]*.bot[BOT_WIDTH] +. bot[BOT_LENGTH]*.bot[BOT_LENGTH])/.2.0
  acctime := getms()
  if debugoutput()
    serial.fstr3(string("Swerve starting %.2g %.2g %.2g\r"), bot[BOT_WIDTH], bot[BOT_LENGTH], rad)

  retv := motor.start(scl, sda, pinvert)

  encoder.start(epin, 0, MAXANGLE)                         ' 0-MAXANGLE output

  repeat ch from 0 to MAX_SWERVE_MODULES-1
    pid[ch].init(ch, MAXANGLE, MAXSPEED)                   ' 0-MAXANGLE input, +- MAXSPEED output
    pid[ch].setposition(0)                                 ' start angle
  if debugoutput()
    serial.fstr1(string("Swerve started %x\r"), retv)

PUB setpidconstants(Kp, Ki, Kd, overmax) | ch
  overridemax := overmax
  '' config pid constants for steering pids
  repeat ch from 0 to MAX_SWERVE_MODULES-1
    pid[ch].setconstants(ch, Kp, Ki, Kd)

PRI setmotorspeeds(pspeeds) | ch, speed
  ' set all motor speeds, drive and angle
  ' swerve modules on 1st and 2nd motor driver
  repeat ch from 0 to 7
    speed := long[pspeeds][ch]
    ' final clamping to max motor speed
    motor.run(ch, abs(speed) > minmotorspeed[ch&1] ? utilities.clamp(speed, overridemax) : 0)

PRI angletospeed(pspeeds, pangles) : retv | rawangle, currentangle, requestangle, ch, wrappedangle, ponespeed
  ' convert required angle to motor speed to get there
  ' return false if all swerves are at correct angle
  repeat ch from 0 to MAX_SWERVE_MODULES-1
    ponespeed := @long[pspeeds][ch<<1]
    currentangle := ((rawangle := encoder.read(ch)) + angleoffsets[ch]) // MAXANGLE ' current angular position, allow for encoder offset and wrap to 0..MAXANGLE
    pid[ch].currentposition(currentangle)               ' current angle of swerve
    ' if request/current angle > MAXANGLE/2 apart then pid will wrap and invert
    ' if request/current angles > MAXANGLE/4 apart then invert the drive speed and subtract MAXANGLE/4 from requestangle
    wrappedangle := utilities.wrapangles(requestangle := long[pangles][ch], currentangle, MAXANGLE)
    if debugoutput()
      serial.fstr8(string("Swerve1 %s %d %d %d %d %x %d %x\r"), @@sptr[ch], rawangle, currentangle, long[ponespeed], requestangle, requestangle, wrappedangle, wrappedangle)
    if(abs(wrappedangle) > MAXANGLE/4)
      ' change request angle by MAXANGLE/2
      requestangle -= (requestangle > 0) ? (MAXANGLE/2) : -MAXANGLE/2
      ' and invert the drive speed
      -= long[ponespeed]
      if debugoutput()
        serial.fstr4(string("Swerve1a %s %d %d %d\r"), @@sptr[ch], wrappedangle, requestangle, long[ponespeed])
    if debugoutput()
      serial.fstr8(string("Swerve2 %s %d %d %d %d %x %d %x\r"), @@sptr[ch], rawangle, currentangle, long[ponespeed], requestangle, requestangle, wrappedangle, wrappedangle)
    pid[ch].setposition(requestangle)                   ' wanted angle of swerve
    ' slowdown drive speed depending on how far out of alignment the swerve module is
    long[ponespeed] := qcos(long[ponespeed], abs(requestangle - currentangle), MAXANGLE)
    retv |= (long[ponespeed][1] := pid[ch].output()) <> 0 ' speed to move steering motor
    if debugoutput()
      serial.fstr6(string("Swerve3 %s %d %d %d %d %d\r"), @@sptr[ch], long[ponespeed], long[ponespeed][1], long[pangles][ch], requestangle, wrappedangle)

PRI scalemaxspeed(pspeeds) | highest, index
  ' scale max speeds if over or under MAXSPEED
  ' find the largest absolute drive speed
  highest := utilities.maxlong(pspeeds, 4, D_FRONT_RIGHT-D_FRONT_LEFT)

  ' if largest absolute speed is above MAXSPEED then scale drive speeds to get the largest to MAXSPEED
  if(highest > MAXSPEED)
    repeat index from D_FRONT_LEFT to D_BACK_RIGHT step D_FRONT_RIGHT-D_FRONT_LEFT
      long[pspeeds][index] := scalespeed(long[pspeeds][index], highest)
  if debugoutput()
    serial.fstr4(string("Swerve maxspeeds %d %d %d %d\r"), long[pspeeds][D_FRONT_LEFT], long[pspeeds][D_FRONT_RIGHT], long[pspeeds][D_BACK_LEFT], long[pspeeds][D_BACK_RIGHT])

PRI scalespeed(in, max) : scaled
  scaled := muldiv64(abs(in), MAXSPEED, max)
  if in < 0
    -= scaled

PRI calculate(x, y, r, pspeeds, pangles) | a, b, c, d, afl, afr, abl, abr
' translate x, y and rotation into swerve speed and angle per swerve module
  abl := float(r)
  afr, afl := round(abl *. bot[BOT_WIDTH]/.rad), round(abl *. bot[BOT_LENGTH]/.rad)
  a, b, c, d :=  x - afr, x + afr, -y - afl, -y + afl
  if debugoutput()
    serial.fstr4(string("Swerve calculate %d %d %d %d\r"), a, b, c, d)

  ' xypol returns length and unsigned 32-bit angle, where $00000000..$FFFFFFFF = 0..359.9999999 degrees
  ' scale angle tp MAXANGLE
  long[pspeeds][D_BACK_RIGHT],  long[pangles][A_BACK_RIGHT]  := scaleangle(xypol(a, d))     ' back, right
  long[pspeeds][D_FRONT_RIGHT], long[pangles][A_FRONT_RIGHT] := scaleangle(xypol(a, c))     ' front, right
  long[pspeeds][D_BACK_LEFT],   long[pangles][A_BACK_LEFT]   := scaleangle(xypol(b, d))     ' back, left
  long[pspeeds][D_FRONT_LEFT],  long[pangles][A_FRONT_LEFT]  := scaleangle(xypol(b, c))     ' front, left

  if debugoutput()
    serial.fstr4(string("Swerve %s speed/angle %d %d(%.2f)\r"), @@sptr[0], long[pspeeds][D_FRONT_LEFT], long[pangles][A_FRONT_LEFT], muldiv64(long[pangles][A_FRONT_LEFT], 36000, MAXANGLE))
    serial.fstr4(string("Swerve %s speed/angle %d %d(%.2f)\r"), @@sptr[1], long[pspeeds][D_FRONT_RIGHT], long[pangles][A_FRONT_RIGHT], muldiv64(long[pangles][A_FRONT_RIGHT], 36000, MAXANGLE))
    serial.fstr4(string("Swerve %s speed/angle %d %d(%.2f)\r"), @@sptr[2], long[pspeeds][D_BACK_LEFT], long[pangles][A_BACK_LEFT], muldiv64(long[pangles][A_BACK_LEFT], 36000, MAXANGLE))
    serial.fstr4(string("Swerve %s speed/angle %d %d(%.2f)\r"), @@sptr[3], long[pspeeds][D_BACK_RIGHT], long[pangles][A_BACK_RIGHT], muldiv64(long[pangles][A_BACK_RIGHT], 36000, MAXANGLE))

PRI scaleangle(ind, inangle) : rd, scaledangle
  rd, scaledangle := ind, utilities.scaleangle(inangle, MAXANGLE)

CON
  ACCINTERVAL   = 100                                       ' acceleration limiting interval, ms
  ACCSHIFT      = 3
  ACCLIMIT      = 1<<ACCSHIFT                               ' acceleration increments

PRI adjustandclampspeed(lastspeed, newspeed) : adjustedspeed | deltaspeed, upperclampspeed, lowerclampspeed

  deltaspeed := newspeed - lastspeed                        ' delta is /8 or 12.5% of the difference between current and requested speeds
  lowerclampspeed, upperclampspeed := newspeed, lastspeed
  if newspeed > lastspeed
    lowerclampspeed, upperclampspeed := lastspeed, newspeed ' default doesn't apply in this case
  deltaspeed += (deltaspeed > 0) ? ACCLIMIT : -ACCLIMIT     ' make sure delta doesn't reduce to 0
                                                            ' clamp makes sure delta doesn't overrun
  adjustedspeed := utilities.fullclamp(lastspeed + (deltaspeed>>ACCSHIFT), lowerclampspeed, upperclampspeed)

PRI limitacceleration(x, y, r) : lx, ly, lr, changed, notcomplete | lcx, lcy, lcr

  ' update speeds every ACCINTERVAL ms
  if(getms() > acctime)
    longmove(@lcx, @lastcx, 3)                              ' save for debug output
    lastcx := adjustandclampspeed(lastcx, x)
    if debugoutput()
      serial.fstr3(string("Swerve x limit %d %d %d\r"), lcx, x, lastcx)
    lastcy := adjustandclampspeed(lastcy, y)
    if debugoutput()
      serial.fstr3(string("Swerve y limit %d %d %d\r"), lcy, y, lastcy)
    lastcr := adjustandclampspeed(lastcr, r)
    if debugoutput()
      serial.fstr3(string("Swerve r limit %d %d %d\r"), lcr, r, lastcr)
    acctime := getms() + ACCINTERVAL
    changed := true
  ' output not matching input speed
  notcomplete := utilities.longcomp(@lastcx, @x, 3, false)
  longmove(@lx, @lastcx, 3)

PUB update(x, y, r, off) : notcomplete | changed, newoffstate, previousoffstate
'' return true if needs calling again, either not fully update to speed or swerve angle not in position

  if debugoutput()
    serial.fstr4(string("Swerve updating x:%d, y:%d, r:%d off: %d\r"), x, y, r, off)

  newoffstate, previousoffstate := motorsoff(off)
  ifnot newoffstate
    x, y, r, changed, notcomplete := limitacceleration(x, y, r)
    if(changed == true)
      if debugoutput()
        serial.fstr3(string("Swerve updating after limiting x:%d, y:%d, r:%d\r"), x, y, r)

      calculate(x, y, r, @speeders, @angles)            ' calculate speed/angle for each swerve module

      scalemaxspeed(@speeders)                          ' scale max drive speeds

      notcomplete |= angletospeed(@speeders, @angles)   ' convert steering angle to steering motor speed

      setmotorspeeds(@speeders)                         ' set speeds of drive and steering motors
  elseifnot previousoffstate
    setmotorspeeds(@zerospeeds)
  if debugoutput()
    serial.fstr3(string("Swerve updated %d %d %d\r"), changed, notcomplete, motorsareoff)

PRI motorsoff(off) : retv, previous
' return true if motors should be off, were off
  previous := motorsareoff\retv := off > 500

PUB debugconfig(tdebug2, tdebug3) | ch
  debug2 := tdebug2
  encoder.updatedebug(tdebug3)
  motor.updatedebug(tdebug3)
  repeat ch from 0 to MAX_SWERVE_MODULES-1
    pid[ch].updatedebug(tdebug3)

PRI debugoutput() : retv
  retv := debug2 > DEBUG_OUTPUT

dat
  zerospeeds  long 0, 0, 0, 0, 0, 0, 0, 0
  sptr long @flptr, @frptr, @blptr, @brptr
  flptr byte "FL", 0
  frptr byte "FR", 0
  blptr byte "BL", 0
  brptr byte "BR", 0
  minmotorspeed long MINDRIVESPEED, MINSTEERINGSPEED
'