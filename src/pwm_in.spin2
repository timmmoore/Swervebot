{Object_Title_and_Purpose}

{
SRX encoder:
        pin 2         5V
        pin 10        Gnd
        pin 9         pwm, 3.3V
PROP2
        pin: 8, 9, 10, 11
}
CON
  NOPWMIN       = 1

  DEBUG_OUTPUT  = 500

  MININCLK      = 90
  MAXINCLK      = 45060

VAR
  long setup
  long pp, minv, maxv                                   ' start pin, min/max values
  long debug1
  long lastvalues[NOPWMIN]
  long angleoffsets[NOPWMIN]                            ' encoder angle offset, 0-MAXANGLE
  long pinoffsets[NOPWMIN]                              ' encoder actual pin

OBJ
  serial        : "isp_serial_singleton_tmm"
  utilities     : "utilities"

PUB null()
  ' This is not a top-level object

PUB start(pin, minvalue, maxvalue, ppinoffsets, poffsets)
  stop()
  longmove(@pp, @pin, 3)
  longmove(@angleoffsets, poffsets, NOPWMIN)            ' angle offset of each encoder
  longmove(@pinoffsets, ppinoffsets, NOPWMIN)           ' actual pin of each encoder
  pinstart(pp ADDPINS NOPWMIN-1, P_HIGH_TICKS, 0, 0)    ' start for NOPWMIN pins, clock ticks for pin high
  setup~~                                               ' mark setup

PUB stop()
  if (setup~)
    pinclear(pp ADDPINS NOPWMIN-1)                      ' disable smart pin
  longfill(@lastvalues, -1, NOPWMIN)

PUB readall(pvals) | ch
  repeat ch from 0 to NOPWMIN-1
    long[pvals][ch] := read(ch, false)

PUB read(ch, display) : out | raw, map
  ' min pulse width 0.9us, max pulse width 4506us
  raw := (rdpin(pp+pinoffsets[ch]) / (clkfreq / 20_000_000)) >> 1 ' convert pulse to 100 picoseconds
  map := utilities.map(raw, MININCLK, MAXINCLK, minv, maxv) ' map to required range
  out := (map + angleoffsets[ch]) // maxv               ' add the angular offset for the encoder and wrap to maxv
  if (out <> lastvalues[ch]\out)
    if debugoutput(UTILITIES.DEBUGOUT1)
      serial.fstr4(string("encoder%d raw:%d map:%d out:%d\r"), pp+ch, raw, map, out)
  if display
    serial.fstr5(string("encoder%d raw:%d map:%d out:%d offset:%.2g\r"), pp+ch, raw, map, out, (float((maxv - map)//maxv)*.360.0)/.1024.0)

PUB updatedebug(tdebug)
  debug1 := tdebug

PRI debugoutput(type) : retv
  retv := utilities.debugoutput(debug1, type)
'