{I2C motor driver}
{}

CON
  MOTOR1            = $40                               ' i2c address first motor board
  MOTOR2            = $41                               ' i2c address second motor board

  ' motor drive configuration
  PCA9685_MODE1     =           $0                      ' register to configure
  PCA9685_PRESCALE  =           $FE                     ' prescaler register
  LED0_ON_L         =           $6                      ' start of led configuration registers
                                                        ' per led: on low, on high, off low, off high
  LED_ALWAYS        =           4096                    ' bit 12 set means always on/off

  NO_MOTOR1         =           $02
  NO_MOTOR2         =           $04

  PCA9685_I2C_SPEED =           800                     ' 1000 works but is not consistent
                                                        ' try again with shorter shielded wires

  DEBUG_OUTPUT      =           500

VAR
  word debug2
  long pinvert
  long uscount

OBJ
  serial        : "isp_serial_singleton_tmm"
  i2c           : "jm_i2c_tmm"
  utilities     : "utilities"

PUB null()
  ' This is not a top-level object

PUB start(scl, sda, ppinvert) : retv | ch
  pinvert := ppinvert
  uscount := clkfreq /1_000_000
  ifnot i2c.setup(scl, sda, PCA9685_I2C_SPEED, i2c.PU_3K3, -1) ' i2c @ 800kHz, 1K5 pull-ups
    return $01|NO_MOTOR1|NO_MOTOR2

  if(i2c.present(MOTOR1<<1) == true)
    if debugoutput(UTILITIES.DEBUGOUT4)
      serial.fstr0(string("Swerve found motor board1\r"))
  else
    if debugoutput(UTILITIES.DEBUGOUT1)
      serial.fstr0(string("Swerve not found motor board1\r"))
    retv |= NO_MOTOR1
  i2c.stop()
  if(i2c.present(MOTOR2<<1) == true)
    if debugoutput(UTILITIES.DEBUGOUT4)
      serial.fstr0(string("Swerve found motor board2\r"))
  else
    if debugoutput(UTILITIES.DEBUGOUT1)
      serial.fstr0(string("Swerve not found motor board2\r"))
    retv |= NO_MOTOR2
  i2c.stop()
  ifnot retv & NO_MOTOR1
    initpwm(MOTOR1)
  ifnot retv & NO_MOTOR2
    initpwm(MOTOR2)
  repeat ch from 0 to 15                                ' all pins off
    ifnot retv & NO_MOTOR1
      setPWM(MOTOR1<<1, ch+LED0_ON_L, 0)
    ifnot retv & NO_MOTOR2
      setPWM(MOTOR2<<1, ch+LED0_ON_L, 0)

PRI initpwm(addr) | oldmode
  '' init pwm on motor driver board
  if debugoutput(UTILITIES.DEBUGOUT4)
    serial.fstr1(string("initpwm %x\r"), addr)
  write8(addr, PCA9685_MODE1, $0)
  oldmode := read8(addr, PCA9685_MODE1)
  write8(addr, PCA9685_MODE1, (oldmode&$7F) | $10)      ' go to sleep
  write8(addr, PCA9685_PRESCALE, 3)                     ' set the prescaler
  write8(addr, PCA9685_MODE1, oldmode)
  waitus(5)
  write8(addr, PCA9685_MODE1, oldmode | $a1)            ' This sets the MODE1 register to turn on auto increment.
  if debugoutput(UTILITIES.DEBUGOUT4)
    serial.fstr1(string("initpwm done %x\r"), addr)

PRI read8(addr, adr) : ret1
  '' read byte from motor driver
  i2c.start()
  i2c.write(addr<<1)
  i2c.write(adr)

  i2c.start()
  i2c.write(addr<<1|1)
  ret1 := i2c.read(i2c.NAK)
  i2c.stop()

PRI write8(addr, adr, d)
  '' write byte to motor driver
  i2c.start()
  i2c.write(addr<<1)
  i2c.write(adr)
  i2c.write(d)
  i2c.stop()

PRI setPWM(addr, num, value) | word values[3]
  '' set PWM on/off for single motor pin on motor driver board
  values.byte[0] := addr
  values.byte[1] := num
  wordmove(@values[1], @value, 2)
  i2c.start()
  i2c.wr_block(@values, 6)
  i2c.stop()
  if debugoutput(UTILITIES.DEBUGOUT4)
    serial.fstr4(string("setpwm done %x %d %d %d\r"), addr, num, values[1], values[2])

PRI setPWMAll(addr, num3, num2, num1, value1, value2, value3)
  '' set direction/PWM values for a motor on motor driver board
  ' sort led registers and values, led registers need to be contiguous
  ' registers in reverse order to values and register value is in MSB of numX.
  if num3 +< num1
    num1, num3, value1, value3 := num3, num1, value3, value1
  elseif num2 +< num1
    num1, num2, value1, value2 := num2, num1, value2, value1
  if num3 +< num2
    value2, value3 := value3, value2                    ' dont bother swapping num values as not needed
  ' insert PCA9685 addr and first register and write sorted values to PCA9685
  num1 |= addr                                          ' addr value is in byte 2 of addr
  i2c.start()
  i2c.wr_block(@num1.word[1], 14)
  i2c.stop()                                            ' pins are updated on I2C stop so write order for one batch doesn't matter
  if debugoutput(UTILITIES.DEBUGOUT3)
    serial.fstr7(string("setpwmall done %x %d %x %d %x %d %x\r"), addr, num1, value1, num2, value2, num3, value3)

PUB run(motor, speed) | addr, pwm, in1, in2, in2v, pwmv, temp
'' set speed of 1 motor of a swerve module

  ' lookup PCA9865 board address and PCA9865 led registers used for each motor driver pin: pwm, in1, in2
  ' note addr is already << 1 shifted and pins are register indexes
  addr, pwm, in1, in2 := addrs[motor>>2], pwmpins[temp:=motor&3], in1pins[temp], in2pins[temp]

  ' set the direction and pwm pin values
  if (pwmv := abs(speed)) <> 0
    in2v := LED_ALWAYS
    pwmv := pwmv >= in2v ? in2v : pwmv<<16

  ' invert the direction registers if needed by switching the 2 direction pins
  if word[pinvert][motor] ^^ (speed < 0)
    'serial.fstr5(string("invert1 %d %d, %.8x %.8x %d\r"), word[pinvert][motor], motor, in2, in1, speed)
    in1, in2 := in2, in1
    'serial.fstr5(string("invert2 %d %d, %.8x %.8x %d\r"), word[pinvert][motor], motor, in2, in1, speed)

  temp := getct()
  ' 210-215us
  setPWMAll(addr, pwm, in2, in1, 0, in2v, pwmv)
  temp := getct() - temp - 40
  if debugoutput(UTILITIES.DEBUGOUT3)
    serial.fstr7(string("run motor %.8x %d %.8x %.8x %.8x %d %d\r"), addr, motor, pwm, in2, in1, speed, temp/uscount)

PRI debugoutput(type) : retv
  retv := utilities.debugoutput(debug2, type)

PUB updatedebug(tdebug)
  debug2 := tdebug

DAT
  ' PCA9865 register mapping to TB6612
  pwmpins     long ((2<<2)+LED0_ON_L)<<24, ((7<<2)+LED0_ON_L)<<24,  ((8<<2)+LED0_ON_L)<<24, ((13<<2)+LED0_ON_L)<<24
  in1pins     long ((4<<2)+LED0_ON_L)<<24, ((5<<2)+LED0_ON_L)<<24, ((10<<2)+LED0_ON_L)<<24, ((11<<2)+LED0_ON_L)<<24
  in2pins     long ((3<<2)+LED0_ON_L)<<24, ((6<<2)+LED0_ON_L)<<24,  ((9<<2)+LED0_ON_L)<<24, ((12<<2)+LED0_ON_L)<<24
  ' I3C addresses for 2 PCA9865
  addrs       long (MOTOR1<<1)<<16, (MOTOR2<<1)<<16
'